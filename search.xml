<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Windows使用CLion</title>
      <link href="/2018/07/08/Windows%E4%BD%BF%E7%94%A8CLion/"/>
      <url>/2018/07/08/Windows%E4%BD%BF%E7%94%A8CLion/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>CLion<br>从<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">官网</a>下载安装</p></li><li><p>Linux环境（msys2）<br>从<a href="https://sourceforge.net/projects/msys2/" target="_blank" rel="noopener">sourceforge</a>上下载，安装，安装好后运行以下命令更新：</p><blockquote><p>pacman -Syu</p></blockquote></li></ol><p>更新完后，安装工具链：</p><blockquote><p>pacman -S mingw-w64-x86_64-toolchain</p></blockquote><p>安装完成后此时基本就可以使用，但是如果要使用<code>LLVM</code>的话，还得安装：</p><blockquote><p>pacman -S mingw-w64-x86_64-llvm mingw-w64-x86_64-clang</p></blockquote><p>全部安装完成后，环境也就基本搭建好了。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在<code>CLion</code>的<code>Settings</code>界面的<code>Build, Execution, Deployment</code>中找到<code>Toolchains</code>。新建一个运行环境，选择<code>MinGW</code>，选择通过<code>msys2</code>安装好的路径，此时后续的<code>CMake</code>等会自动检测。如果使用默认的<code>GCC</code>工具链，那么此时配置就算完成了。但是想要使用<code>LLVM</code>，还得在<code>CMake</code>选项中进行配置，主要配置的选项是：</p><blockquote><p>CMake options: -D_CMAKE_TOOLCHAIN_PREFIX=llvm-<br><br>Environment: CC=path//to//clang.exe;CXX=path//to//clang++.exe</p></blockquote><h1 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h1><ol><li><code>xxx is not able to compile a simple test program.</code><br>这有可能是权限问题，也有可能是缓存问题。可以尝试将<code>C:\\Users\\xxx\\.CLion</code>清空，然后重新配置<code>CLion</code>。</li></ol>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript是如何工作的：引擎、运行时与调用栈</title>
      <link href="/2018/02/03/JavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9A%E5%BC%95%E6%93%8E%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8E%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2018/02/03/JavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9A%E5%BC%95%E6%93%8E%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8E%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>随着<code>Nodejs</code>的出现，<code>JavaScript</code>就变得无处不在。前端、后端、混合App、嵌入式设备等。在<code>Github</code>上，<code>JavaScript</code>标签的项目也是逐年增长，伴随着<code>ES2015</code>标准的发布，<code>JavaScript</code>也变得<code>现代</code>起来。作为一名开发者，不仅要知道<code>JavaScript</code>的基础语法，同时也由必要了解<code>JavaScript</code>是如何运行的，这里面都牵扯到哪些东西。知道其背后的运行原理，有利于深刻了解我们平常写的代码，同时更好地利用现有的<code>API</code>。</p><h1 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h1><p>目前最受欢迎的就是Google的<code>V8</code>引擎了。<code>V8</code>被用在了<code>Google Chrome</code>和<code>Node.js</code>中。下面的图形简单展示了<code>JavaScript</code>引擎的基本工作：<br><img src="js-engine.PNG" alt="Engine"></p><p>引擎主要负责两部分：</p><ul><li>内存管理：也就是内存的分配与释放</li><li>调用栈管理：也就是执行代码时的栈帧管理</li></ul><h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><p>在日常开发中，我们还会一些其他的<code>API</code>，比如<code>setTimeout</code>，这些<code>API</code>都是执行在浏览器环境中，这些<code>API</code>自然不是<code>JavaScript引擎</code>提供的。这些都称之为<code>Web API</code>，是由浏览器提供的，除了<code>setTimeout</code>，还有操作<code>DOM</code>的，<code>AJAX</code>等。除去这些还有用来相应<code>DOM</code>事件的<code>事件循环</code>和<code>回调队列</code>。<br><img src="browser.PNG" alt="browser"></p><h1 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h1><p><code>JavaScript</code>的执行是单线程的，这意味这它只有一个调用栈。<code>调用栈</code>说白了就是数据结构，用来记录当前代码执行的一些信息。比如说下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>当上述的代码开始执行时，<code>调用栈</code>是空的。之后开始调用<code>printSquare</code>，接着<code>multiply</code>，接着<code>console</code>，然后开始出栈。形象化表示是这样的：<br><img src="stack.PNG" alt="CallStack"></p><p>调用栈中的每个条目称之为<code>栈帧（Stack Frame）</code></p><p>这里包含了两个情况：</p><ul><li>异常</li><li>递归调用</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>如果上述代码运行在<code>Chrome</code>中的话，我们可以在<code>Chrome Del Tools</code>的<code>Console</code>面板中发现会输出一行错误：<br><img src="exception.png" alt="exception"></p><p>上面的错误直接反映了调用栈的结构。</p><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>递归调用直接导致的后果就是栈溢出，也就是超过了最大栈大小。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>上述代码如果在<code>Chrome</code>中，会发现进程会卡死一段时间，然后在<code>Chrome Del Tools</code>的<code>Console</code>面板中出现错误:<br><img src="stackError.png" alt="stack"></p><p>调用栈形象化表示是这样的：<br><img src="stackOver.png" alt="stack"></p><h1 id="并发与事件循环"><a href="#并发与事件循环" class="headerlink" title="并发与事件循环"></a>并发与事件循环</h1><p>因为<code>JavaScript</code>是单线程，所以如果要执行一个耗时的操作，比如复杂的图片转换，就会导致页面出现卡顿现象。此时就无法相应界面的任何操作，导致了非常不好的用户体验。甚至有时会出现以下的提示：<br><img src="stuck.jpeg" alt="stuck"></p><p>解决这个问题的办法就是使用<code>异步回调（asynchronous callbacks）</code>。</p><p>这个将在下一篇详细解释。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu下使用SS</title>
      <link href="/2017/12/09/Ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8SS/"/>
      <url>/2017/12/09/Ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8SS/</url>
      <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Ubuntu 16.04，连接到互联网。</p><h1 id="安装、配置、启动ss"><a href="#安装、配置、启动ss" class="headerlink" title="安装、配置、启动ss"></a>安装、配置、启动ss</h1><p>安装命令：</p><blockquote><p>sudo apt-get install python-pip<br>pip install shadowsocks</p></blockquote><p>运行<code>sslocal</code>时需要指定几个参数：</p><blockquote><p>“server”: “服务器的ip”,<br>“server_port”: 服务器的端口,<br>“local_port”: “127.0.0.1”,<br>“password”: 1080<br>“timeout”: 500,<br>“method”: “aes-256-cfb”</p></blockquote><p>上述参数可以在命令行中指定，也可使用配置文件，然后用指定配置文件启动<code>sslocal</code></p><blockquote><p>sslocal -c /home/test/shadowsocks.json</p></blockquote><p>每次输入太麻烦，可以写个脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment">#shadow.sh</span></span><br><span class="line">sslocal -c /home/<span class="built_in">test</span>/shadowsocks.json</span><br></pre></td></tr></table></figure><p>不管在终端中输入还是运行脚本，整个终端会被占据，所以可能需要后台运行：</p><blockquote><p>nohup sh /home/usr/shadow.sh &gt; /home/usr/log.out 2&gt;&amp;1 &amp;</p></blockquote><p>但是我们不想每次都手动去输入上面的命令，解决的办法就是加入开机运行，将上述命令加到<code>rc.local</code>文件。编辑<code>rc.local</code>文件，在<code>exit</code>前输入上述命令。然后<code>reboot</code>。</p><p>上述设置后，一切运行正常，但是想通过<code>chrome</code>上外网，发现还是不行。有两个方法可以让<code>chrome</code>上外网，第一个是<code>HTTP</code>代理，第二个是<code>SwitchOmega</code>。</p><h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>安装<code>polipo</code>进行<code>HTTP</code>代理：</p><blockquote><p>sudo apt-get install polipo</p></blockquote><p>修改<code>polipo</code>配置文件(/etc/polipo/config)如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file only needs to list configuration variables that deviate</span></span><br><span class="line"><span class="comment"># from the default values. See /usr/share/doc/polipo/examples/config.sample</span></span><br><span class="line"><span class="comment"># and "polipo -v" for variables you can tweak and further information.</span></span><br><span class="line">logSyslog = <span class="literal">false</span></span><br><span class="line">logFile = <span class="string">"/var/log/polipo/polipo.log"</span></span><br><span class="line"></span><br><span class="line">socksParentProxy = <span class="string">"127.0.0.1:1080"</span></span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">serverMaxSlots = 64</span><br><span class="line">serverSlots = 16</span><br><span class="line">serverSlots1 = 32</span><br><span class="line"></span><br><span class="line">proxyAddress = <span class="string">"0.0.0.0"</span></span><br><span class="line">proxyPort = 8123</span><br></pre></td></tr></table></figure><p>重启<code>polipo</code>:</p><blockquote><p>/etc/init.d/polipo restart</p></blockquote><p>此时可一检测下代理是否正常运行：</p><blockquote><p>export http_proxy=”<a href="http://127.0.0.1:8123/&quot;" target="_blank" rel="noopener">http://127.0.0.1:8123/&quot;</a><br>curl <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p></blockquote><p>如果一切正常，终端会显示抓取到的<code>Google</code>网页的内容。</p><h3 id="Chrome参数"><a href="#Chrome参数" class="headerlink" title="Chrome参数"></a>Chrome参数</h3><p>上述一切正常运行，从左侧启动<code>Chrome</code>，依旧无法上外网。上面能正常抓取<code>Google</code>网页是因为在那个<code>Terminal</code>中加入了<code>http_proxy</code>变量。所以也要把类似<code>http_proxy</code>的代理加入到启动<code>Chrome</code>参数中。<code>Luancher</code>中的启动项可以在<code>usr/share/applications</code>下找到。编辑此目录下的<code>google-chrome.desktop</code>文件，找到<code>Exec</code>命令行，在末尾加入<code>http</code>代理服务器配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=/usr/bin/google-chrome-stable --incognito --proxy-server=<span class="string">"http://127.0.0.1:8123"</span></span><br></pre></td></tr></table></figure><p>从<code>Luancher</code>的<code>Chrome</code>图标中，有三处可以启动，因此需要找到另外两个<code>Exec</code>命令行，加入：</p><blockquote><p>–proxy-server=”<a href="http://127.0.0.1:8123&quot;" target="_blank" rel="noopener">http://127.0.0.1:8123&quot;</a></p></blockquote><h2 id="SwitchOmega"><a href="#SwitchOmega" class="headerlink" title="SwitchOmega"></a>SwitchOmega</h2><p>可以从<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">Github</a>上下载最新的<code>chrome</code>版。在<code>Chrome</code>地址栏输入<code>chrome://extensions</code>打开扩展程序，拖动 .crx 后缀的<code>SwitchyOmega</code>安装文件到扩展程序中进行安装。</p><p>安装成功后，增加一个类型为<code>Proxy Profile</code>的配置文件，或者直接在原有的修改：</p><ul><li>Protocol: SOCKS5</li><li>Server: 127.0.0.1</li><li>Port: 1080</li></ul><p>然后点击<code>Apply Changes</code>。</p><p>同时也可以增加一个<code>Switch Profile</code>的配置文件，这个可以自动根据一个域名的列表清单自动选择是否需要代理。配置文件进行如下修改：</p><ul><li>Switch rules的 Rule list rules的Profile列选择上述的proxy配置文件名</li><li>Rule List URL: <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，点击下载" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，点击下载</a></li></ul><p>然后点击<code>Apply Changes</code>。</p><p>这是就可以在扩展图标中选择<code>SwitchOmega</code>，然后选择自动切换选项。 </p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ss </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何读取OLE控件的PropertyBag</title>
      <link href="/2017/09/16/%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96OLE%E6%8E%A7%E4%BB%B6%E7%9A%84PropertyBag/"/>
      <url>/2017/09/16/%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96OLE%E6%8E%A7%E4%BB%B6%E7%9A%84PropertyBag/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>&ensp;&ensp;&ensp;本篇的目的就是记录下如何获取OLE控件的属性页的全部属性。想要达到这个目的的时候，在网上搜寻了一番，基本没找到可用的信息。因此就开始自我探寻。碰巧之前在开发OLE的时候，见到有个叫TstCon.exe的工具，这个工具的功能就是类似加载系统注册的OCX控件。后来在<a href="https://github.com/Microsoft/VCSamples" target="_blank" rel="noopener">github</a>上找到了源码，因此问题也就迎刃而解了。在此简单记录一下。</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>&ensp;&ensp;&ensp;获取控件的接口<code>IPersistPropertyBag</code>指针，这个可以通过<code>QueryInterface</code>取得：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT hResult;</span><br><span class="line">IPersistPropertyBagPtr pPersistPropertyBag;</span><br><span class="line"></span><br><span class="line">hResult = m_lpObject-&gt;QueryInterface( IID_IPersistPropertyBag,(<span class="keyword">void</span>**)&amp;pPersistPropertyBag );</span><br></pre></td></tr></table></figure></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>&ensp;&ensp;&ensp;在<code>IPersistPropertyBagPtr</code>接口中，还没办法直接获取PropertyBag。而是调其方法，将属性保存到一个实现了接口<code>IPropertyBag</code>的类中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPropertyBag* pPropertyBag</span><br><span class="line">hResult = pPersistPropertyBag-&gt;Save(pPropertyBag, TRUE, TRUE);</span><br></pre></td></tr></table></figure></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>&ensp;&ensp;&ensp;实现一个继承了<code>IPropertyBag</code>的类。<code>IPropertyBag</code>接口有以下方法需要实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT* pvarValue, IErrorLog* pErrorLog);</span><br><span class="line">STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT* pvarValue);</span><br></pre></td></tr></table></figure></p><p>也就是一个读一个写。写方法由<code>pPersistPropertyBag-&gt;Save</code>将OCX控件内的属性读入到<code>IPropertyBag</code>的实现类中。然后可以用读方法，通过属性名获取其值。通常情况下可能还需要实现<code>IUnknown</code>的三个接口用来管理COM指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STDMETHOD_(ULONG, AddRef)();</span><br><span class="line">STDMETHOD_(ULONG, Release)();</span><br><span class="line">STDMETHOD(QueryInterface)(REFIID iid, <span class="keyword">void</span>** ppInterface);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;可以确定的是，在<code>IPropertyBag</code>的实现类中需要用队列或者某种方式保存KV对。这样才能在<code>pPersistPropertyBag-&gt;Save</code>调用之后，属性值能被外界读取。而在<code>TstCon</code>的源码中恰好实现了一个PropertyBag类。几乎可以重用它的所有代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&ensp;&ensp;&ensp;<code>TstCon</code>的源码中有很多设计是比较经典的，因为它实现了一个<code>OCX控件</code>容器的功能。如果是在基于<code>MFC</code>的<code>OCX控件</code>的展示，配置等，有很多代码的设计可以借鉴。当然这个技术实在是太古老了，目前在新项目中很少人会选择这样的技术，网上的相关资源也越来越少，遇到棘手问题只能自行解决。了解这个技术所带来的回报也越来越低，能用到的最多也只是维护老项目过程中。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> OLE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React：组件mount初探</title>
      <link href="/2017/09/02/React%EF%BC%9A%E7%BB%84%E4%BB%B6mount%E5%88%9D%E6%8E%A2/"/>
      <url>/2017/09/02/React%EF%BC%9A%E7%BB%84%E4%BB%B6mount%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;<a href="http://codingwith.me/2017/08/19/React%E4%B8%8EQt%20WebEngine/">上一篇</a>提及到，因为直接将<code>React</code>组件以AMD格式导出给<code>Qt WebEngine</code>使用，导致<code>React</code>在调用方<code>new</code>的时候直接对组件进行mount，却只因只加载最外层的<code>TopLevelWrapper</code>，而没有mount里面组件，导致整个组件未被正确加载（因为环境目前已被重构，具体原因还未深入探究。待之后有时间重新搭平台查询原因）。</p><h1 id="组件mount整体流程"><a href="#组件mount整体流程" class="headerlink" title="组件mount整体流程"></a>组件mount整体流程</h1><p>&ensp;&ensp;&ensp;当写下面这样的代码后：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;Hello &#123;<span class="keyword">this</span>.props.msg&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Hello /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><code>React</code>会做以下几件事情：</p><ul><li>根据render中的类型实例化元素类型，比如是原生元素还是组合组件；</li><li>在container（也就是document.getElementById(‘root’)）中根据上述的类型创建DOM元素；</li></ul><p>&ensp;&ensp;&ensp;简单来说<code>React</code>就是做了以上两件事情。当然其中有很多细节，比如组件嵌套时，需要递归创建实例，然后在DOM创建相应的DOM节点，比如需要对组件的生命期进行管理。也就是：</p><h2 id="组件mount"><a href="#组件mount" class="headerlink" title="组件mount"></a>组件mount</h2><p><code>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</code></p><h2 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h2><p><code>componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</code></p><p><code>React</code>需要在以上的阶段适当地调用用户的回调函数。在实现组件的<code>mount</code>过程中，使用了几个全局的操作：</p><ul><li>ReactUpdates的batch</li><li>Transaction</li><li>ReactReconciler</li></ul><p>其中各个功能另外再表，在此不多说。</p><h1 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h1><p>&ensp;&ensp;&ensp;从最初的用户代码的<code>render</code>开始。从<code>render</code>的签名来看，就是把第一个参数的组件，渲染到第二个DOM节点（也就是称之为container）中。<code>React</code>源码基于v16.0-beta。</p><h2 id="第一步：确认节点类型，创建内部节点实例"><a href="#第一步：确认节点类型，创建内部节点实例" class="headerlink" title="第一步：确认节点类型，创建内部节点实例"></a>第一步：确认节点类型，创建内部节点实例</h2><p>&ensp;&ensp;&ensp;在<code>_renderSubtreeIntoContainer</code>中获取<code>container</code>的顶层节点来判断是否更新已有的节点，还是创建新的根节点。在此只讨论新建根节点情况。</p><p>&ensp;&ensp;&ensp;在<code>_renderNewRootComponent</code>中，根据节点类型创建实例。有几种类型：</p><ul><li>node为null或false时，创建类型<code>ReactEmptyComponent</code>实例</li><li>node为对象时，根据node的element的type来创建<ul><li>type为string时，创建类型为<code>ReactHostComponent.createInternalComponent</code>实例</li><li>type为内部组件类型时，直接调用其构造函数</li><li>其他情况，创建类型<code>ReactCompositeComponentWrapper</code>实例</li></ul></li><li>node为string时，创建类型<code>ReactHostComponent.createInstanceForText</code>实例</li></ul><p>&ensp;&ensp;&ensp;接下来就是根据不同的实例进行组件的<code>mount</code>操作。其中<code>mount</code>过程通过<code>ReactUpdates.batchedUpdates</code>进行调用。元素类型来说可以分为两类:</p><ul><li>第一类就是和平台环境相关的称之为<code>Host Component</code></li><li>另一类就是用户自定义的，称之为<code>Composite Component</code></li></ul><h2 id="第二步：根据不同节点，递归渲染子节点，构建组件生命周期"><a href="#第二步：根据不同节点，递归渲染子节点，构建组件生命周期" class="headerlink" title="第二步：根据不同节点，递归渲染子节点，构建组件生命周期"></a>第二步：根据不同节点，递归渲染子节点，构建组件生命周期</h2><p>&ensp;&ensp;&ensp;在<code>mountComponentIntoNode</code>中，<code>ReactReconciler.mountComponent</code>会根据第一步的实例，调用各个类型的<code>mountComponent</code>函数。</p><p>&ensp;&ensp;&ensp;在此详细讲述下<code>ReactCompositeComponentWrapper</code>类型实例的<code>mountComponent</code>过程。</p><ol><li>首先是环境的准备，包括元素的<code>props</code>保存，创建上线文<code>context</code>环境，根据组件的类型（函数式也称为纯组件或者类声明）来判断是否需要实例化。</li><li><p>接下来就是构造实例。简单描述下<code>React</code>内部返回给<code>render</code>的实例的几个重要的字段。</p><ul><li><code>_currentElement</code>：主要是保存和组件相关的信息，包括组件类型，props，refs等，用来渲染真实的DOM元素所用</li><li><code>_instance</code>：上述<code>_currentElement</code>的实例</li><li><p><code>_renderedComponent</code>：这是一个内部的类型实例，也就是上面说的<code>Host Component</code>或者<code>Composite Component</code>。当然具体到实例化的时候会有更细的分类</p><p>此处构造的实例就是<code>_instance</code>，包括初始化内部的updater，ref，props等，为组件在更新时所用。确切点说就是会进入组件的构造函数中。同时<code>React</code>会保存这个实例到一个InstanceMap中。实例化完就调用组件<code>生命周期hooks</code>中的<code>componentWillMount</code>，如果有的话。</p></li></ul></li><li><p>构造完实例，接下来就是进行<code>mount</code>了。<code>ReactCompositeComponentWrapper</code>会调用组件中的<code>render</code>方法，同时这里会判断是否有子节点，有的话就对其<code>_instantiateReactComponent</code>，然后对子节点进行<code>mountComponent</code>调用，直到和平台相关的元素为止。递归返回后，将此实例赋给<code>_renderedComponent</code>。</p></li><li><p>执行完<code>mount</code>，回到组件<code>生命周期hooks</code>，也就是调用<code>componentDidMount</code>。整个过程也就算是结束了。</p></li></ol><p>需要注意的一点是，上述的<code>mount</code>是递归构造的。</p><h2 id="第三步：在container中创建相应的原生DOM元素"><a href="#第三步：在container中创建相应的原生DOM元素" class="headerlink" title="第三步：在container中创建相应的原生DOM元素"></a>第三步：在container中创建相应的原生DOM元素</h2><p>&ensp;&ensp;&ensp;在第二步的创建实例过程中，如果元素的类型为<code>string</code>的话，那么会创建<code>ReactHostComponent</code>的<code>InternalComponent</code>，也就是<code>ReactDOMComponent</code>。然后在其<code>mountComponent</code>中，使用<code>render</code>最初传入的<code>Container</code>。使用实例中的<code>_currentElement</code>的信息(包括标签的类型，属性信息等)，在<code>Container</code>中的<code>document</code>中创建相关的元素。在创建相关的元素的过程中，<code>React</code>会做一些相关的处理，比如增加一些注释等等。</p><h1 id="Chrome-Dev-Tool验证"><a href="#Chrome-Dev-Tool验证" class="headerlink" title="Chrome Dev Tool验证"></a>Chrome Dev Tool验证</h1><p>&ensp;&ensp;&ensp;基于最初的那一段代码，从Dev Tool中查看相应的节点信息是否符合上述的源码解释。首先是<code>Top-Level</code>：<br><img src="TopLevel.PNG" alt="TopLevel"><br>可以看到<code>_instance</code>为TopLevelWrapper，其<code>_renderedComponent</code>中的<code>_instance</code>为<code>App</code>，类型为<code>ReactCompositeComponentWrapper</code>，是一个组合组件的类型。</p><p><img src="App.PNG" alt="App"><br>此时，<code>_instance</code>为<code>App</code>，其<code>_renderedComponent</code>已经为<code>Hello</code>，也就是上述写的组件名称，其类型同样为组合组件类型<code>ReactCompositeComponentWrapper</code>。再看下<code>Hello</code>的内部。</p><p><img src="App-rendered.PNG" alt="AppRenderd"><br>可以看到，<code>_instance</code>为<code>Hello</code>，同时，<code>_renderedComponent</code>的类型成了<code>ReactDOMComponent</code>，这个就是上述所说的<code>Host Component</code>中的一种。再看看<code>Hello</code>的<code>_renderedComponent</code>内部。</p><p><img src="Hello.PNG" alt="Hello"><br><code>Hello</code>的<code>_renderedComponent</code>和前面几个已经不一样，因为这已经是叶子节点，也就是最终要渲染到浏览器中的东西，是平台相关的元素。因此里面有两个<code>ReactDOMTextComponent</code>，是最终显示到浏览器中<code>Hello</code>和<code>React</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&ensp;&ensp;&ensp;本文简单阐述了<code>React</code>中的组件<code>mount</code>的过程。包括<code>React</code>创建实例过程中，根据不同的组件类型，创建不同的实例，同时在组件中，递归地去<code>mount</code>其子节点。以及在<code>mount</code>的过程中，何时对用户代码中的<code>生命周期hook</code>函数进行调用。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React与Qt WebEngine</title>
      <link href="/2017/08/19/React%E4%B8%8EQt%20WebEngine/"/>
      <url>/2017/08/19/React%E4%B8%8EQt%20WebEngine/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>&ensp;&ensp;&ensp;因为一些竞争对手以及技术圈大趋势的原因，我们想要尝试着把未来的产品往前端和移动端发展。但是同时因为长期以来，顾客和大部分工程人员都已经熟悉桌面端的应用。所以考虑到这部分人的顾虑，我们没有采取极端的全B/S的形式，但是同时又不能放弃这种可能性。最后就折衷，采取了<code>桌面端使用Qt，同时Qt中使用HTML，未来如果全部迁移到Web或者移动端，那么之前的HTML也可以重用。</code>这样的非主流技术栈。</p><h1 id="React组件如何适配Qt-WebEngine"><a href="#React组件如何适配Qt-WebEngine" class="headerlink" title="React组件如何适配Qt WebEngine"></a>React组件如何适配Qt WebEngine</h1><p>&ensp;&ensp;&ensp;之前做的React组件一直是在Chrome上测试，并且当时以为最后等同事那边的Qt做好以及后台的数据接口改造完后，就直接可以将React组件集成到Qt程序中。</p><p>&ensp;&ensp;&ensp;集成的过程中需要关注以下几点：</p><ul><li>JavaScript的模块风格</li><li>React的组件如何导出类给Qt WebEngine使用</li><li>React组件中的CSS</li></ul><h2 id="模块风格"><a href="#模块风格" class="headerlink" title="模块风格"></a>模块风格</h2><p>&ensp;&ensp;&ensp;这个问题很好解决，因为React组件都是使用Webpack打包，只要在output加一句：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryTarget: <span class="string">"amd"</span></span><br></pre></td></tr></table></figure></p><p>打包后的bundle文件可以直接在Qt 的对接的文件中使用。</p><h2 id="导出类"><a href="#导出类" class="headerlink" title="导出类"></a>导出类</h2><p>&ensp;&ensp;&ensp;通常如果React组件是直接给HTML用，同时HTML也是用模板。那么唯一需要注意的是，React组件放在哪？所以通常情况下会在HTML中加入<code>div</code>节点，同时加上ID，之后在js文件中将React组件加载到这个指定ID的位置。假设有一个名叫<code>CustomeCalendar</code>的组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;CustomeCalendar&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>如果现在是将导出的bundle文件给Qt用，显然不能直接这样进行<code>render</code>。唯一的办法是导出一个类给Qt的接口js使用。第一次想到的是这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCalendar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props. context)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOM.render(</span><br><span class="line">      ...,</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="keyword">this</span>.props.id)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CustomeCalendar;</span><br></pre></td></tr></table></figure></p><p>假设上述React组件的bundle文件就叫<code>bundle.js</code>。在Qt中的接口js中就这么使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'bundle'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">customCalendar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cc = <span class="keyword">new</span> customCalendar(<span class="string">'root'</span>);</span><br><span class="line">  cc.render();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在Qt端，运行起来后，控件也显示了。但是稍后就会发现。React库实际上并没有mount这个组件。因为如果<code>CustomCalendar</code>组件接收来自外界的数据后，使用<code>this.setState()</code>，就会出错。出错的提示类似是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code <span class="keyword">for</span> the <span class="literal">undefined</span> component.</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;这个问题困扰了我1天时间。直到我大概把React组件的mount的过程弄清楚。以上错误输出来源于<code>ReactNoopUpdateQueue</code>，React中还有两类<code>UpdateQueue</code>，<code>ReactUpdateQueue</code>和<code>ReactServerUpdateQueue</code>。正常的组件的<code>UpdateQueue</code>想想也应该是<code>ReactUpdateQueue</code>。而此处出现的<code>ReactNoopUpdateQueue</code>是因为<code>CustomeCalendar</code>根本没有被<code>mount</code>。如果<code>CustomeCalendar</code>没有被<code>mount</code>，那么错误信息是谁输出的？答案是<code>TopLevelWrapper</code>。React加载任何一个组件前都会创建这个顶层的<code>TopLevelWrapper</code>。</p><p>再具体的原因在此不表。可以参考这两篇文章：<a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/" target="_blank" rel="noopener">Under-the-hood-ReactJS</a> 和 <a href="http://www.mattgreer.org/articles/react-internals-part-one-basic-rendering/" target="_blank" rel="noopener">React Internals</a>。</p><p>&ensp;&ensp;&ensp;正确的做法是不要直接导出React组件类，而是普通类，之后由Qt的接口js文件创建这个类的实例，最后调用这个实例的渲染方法，在这个方法里进行<code>ReactDOM.render</code>。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>&ensp;&ensp;&ensp;在集成的过程当中出现了在Chrome中显示正确的控件，而在Qt的WebEngine中确显示异常。根本原因尚未弄清，但是直接原因就是css文件在Qt的WebEngine中的解析和Chrome中的不一样。这只能是在Qt端手动去调整了。没有找到更好的办法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&ensp;&ensp;&ensp;JavaScript控件开发还在继续（比如准备用百度的echarts来做一些数据的展示），集成也在继续。相信之后也还会再遇到一些<code>奇怪</code>的问题。但是不管怎样，有代码的前提下，掌握调试工具是解决问题的基础。通过调试去了解库或控件，问题才能被清晰定位。反过来因为了解了库或控件的内部机制，这样也能更好地使用它，从而避免一些问题。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6模块化</title>
      <link href="/2017/08/12/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2017/08/12/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>JavaScript一直没有在语言层面支持代码的模块化，而是一直通过库来实现。ES6是第一次在标准在引入内建的模块化。</p><h1 id="JavaScript中的模块化"><a href="#JavaScript中的模块化" class="headerlink" title="JavaScript中的模块化"></a>JavaScript中的模块化</h1><p>ES6的模块块集成了之前已有的模块化的大部分有点，包括：</p><ul><li>每个模块都是加载后执行的代码块</li><li>在代码块中，其内的声明（变量声明，函数声明）满足：<ul><li>默认情况下，这些变量的作用域都只在模块内部。</li><li>可以在一些变量前加入export，将变量导出。</li></ul></li><li>一个模块可以从其他模块导入声明。有以下几种方式：<ul><li>通过相对路径（’../model/helpers’），文件后缀.js可以省略。</li><li>通过绝对路径（’/lib/js/healpers’），直接指向要导入的模块</li><li>通过命名方式（’util’），模块名指向的是一个已经配置的名字。</li></ul></li><li>模块都是单例的。即使一个模块导入了多次，只会有一个模块的“实例”存在。</li></ul><h2 id="ES5的模块化"><a href="#ES5的模块化" class="headerlink" title="ES5的模块化"></a>ES5的模块化</h2><p>ES5中存在两种模块化的方式，这两种方式是不兼容的。</p><ul><li>CommonJS 模块化。这个标准的主要实现者是Node.js（但是Node.js的模块化的一些特性要超越CommonJS），有以下特性：<ul><li>紧凑的语法</li><li>用于同步加载和服务器端</li></ul></li><li>Asynchronous Module Definition (AMD)。标准的实现主要是RequireJS，有以下特性：<ul><li>稍微复杂的语法，不需要eval()就能够使AMD工作</li><li>用于异步加载和浏览器端</li></ul></li></ul><h2 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h2><p>ES6模块化设计需要融合了上述两者的优点：</p><ul><li>和CommonJS一样有紧凑的语法，偏向于单导出和支持循环依赖</li><li>和AMD一样，可直接支持异步模式加载和可配置模式的模块加载</li></ul><p>但是同时ES6却要超越上述两者：</p><ul><li>支持语法比CommonJS更紧凑</li><li>支持静态分析（静态检测、优化等）</li><li>支持比CommonJS更好的循环依赖</li></ul><p>ES6模块化标准包括两个部分：</p><ul><li>声明式语法（导入和导出）</li><li>编程式的加载器API，用于配置模块如何加载和模块有条件地加载。</li></ul><h1 id="ES6模块化的基本知识"><a href="#ES6模块化的基本知识" class="headerlink" title="ES6模块化的基本知识"></a>ES6模块化的基本知识</h1><p>ES6支持两种方式的导出，可以同时使用，也可以独立使用，通常情况下是分开使用：</p><ul><li>多个命名的导出（一个模块多个导出）</li><li>单个默认的导出（一个模块一个导出）</li></ul><h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><h3 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h3><ul><li>导出标签式声明</li><li>直接导出 <em>默认导出(Default-exporting)</em> 值</li></ul><h3 id="import和export必须在文件顶部"><a href="#import和export必须在文件顶部" class="headerlink" title="import和export必须在文件顶部"></a>import和export必须在文件顶部</h3><p>因为ES6模块的结构是静态的，所以不能有条件地导入或者导出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random()) &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="string">'foo'</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can’t even nest `import` and `export`</span></span><br><span class="line"><span class="comment">// inside a simple block:</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="string">'foo'</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="import会被提升"><a href="#import会被提升" class="headerlink" title="import会被提升"></a>import会被提升</h3><p>下面的代码会被正确运行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="import的东西在使用方被视为只读"><a href="#import的东西在使用方被视为只读" class="headerlink" title="import的东西在使用方被视为只读"></a>import的东西在使用方被视为只读</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value `counter` is live</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>导入的东西被视为视图有以下好处：</p><ul><li>支持循环依赖，即使是非限定（unqualified ）的导入</li><li>限定（Qualified ）导入和非限定（支持循环依赖，即使是非限定（unqualified）导入以同样的方式运行</li><li>将代码切分到多个模块也可正常运行（只要不修改导出的值）</li></ul><h3 id="支持循环依赖"><a href="#支持循环依赖" class="headerlink" title="支持循环依赖"></a>支持循环依赖</h3><h4 id="CommonJS中的循环依赖"><a href="#CommonJS中的循环依赖" class="headerlink" title="CommonJS中的循环依赖"></a>CommonJS中的循环依赖</h4><p>TBD</p><h4 id="ES6循环依赖"><a href="#ES6循环依赖" class="headerlink" title="ES6循环依赖"></a>ES6循环依赖</h4><p>TBD</p><h1 id="导入与导出"><a href="#导入与导出" class="headerlink" title="导入与导出"></a>导入与导出</h1><h2 id="导出风格"><a href="#导出风格" class="headerlink" title="导出风格"></a>导出风格</h2><ul><li><p>默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> localName <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure></li><li><p>命名空间导出：已对象的方式导出模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> my_lib <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure></li><li><p>具名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name1, name2 &#125; <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Renaming: import `name1` as `localName1`</span></span><br><span class="line"><span class="keyword">import</span> &#123; name1 <span class="keyword">as</span> localName1, name2 &#125; <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Renaming: import the default export as `foo`</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure></li><li><p>空导入。只加载模块，不导入任何东西。会执行模块的代码体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>有两种方式来组合上述的导出：</p><ul><li><p>默认导出和命名空间导出的组合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> theDefault, * <span class="keyword">as</span> my_lib <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br></pre></td></tr></table></figure></li><li><p>默认导出和具名导出的组合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> theDefault, &#123; name1, name2 &#125; <span class="keyword">from</span> <span class="string">'src/my_lib'</span>;</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 具名导出风格：inline vs. clause</span></span><br><span class="line"><span class="string">一种风格是在声明前直接加export关键字</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> myVar1 = ···;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> myVar2 = ···;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MY_CONST = ···;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">myGeneratorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>另外一种是在模块的末尾同一导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_CONST = ···;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; MY_CONST, myFunc &#125;;</span><br></pre></td></tr></table></figure></p><p>也可以以不同的名字导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; MY_CONST <span class="keyword">as</span> FOO, myFunc &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="所有导出风格"><a href="#所有导出风格" class="headerlink" title="所有导出风格"></a>所有导出风格</h2><p>ES6支持一下几种导出风格：</p><ul><li><p>再导出</p><ul><li><p>再导出所有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过子句（clause）再导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo, bar &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过子句（clause）具名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; MY_CONST <span class="keyword">as</span> FOO, myFunc &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>内联（inline）具名导出</p><ul><li><p>变量声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo;</span><br></pre></td></tr></table></figure></li><li><p>函数声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">myGenFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认导出</p><ul><li><p>函数声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">myGenFunc</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>类声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>表达式（注意分号）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'Hello world!'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">3</span> * <span class="number">7</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="建议不要混用默认导出和具名导出"><a href="#建议不要混用默认导出和具名导出" class="headerlink" title="建议不要混用默认导出和具名导出"></a>建议不要混用默认导出和具名导出</h3><h3 id="默认导出只是另外一种具名导出"><a href="#默认导出只是另外一种具名导出" class="headerlink" title="默认导出只是另外一种具名导出"></a>默认导出只是另外一种具名导出</h3><p>下面代码是等同的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ module1.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function declaration!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------ module2.js ------</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="default可以作为导出的名字，但是不能作为变量名"><a href="#default可以作为导出的名字，但是不能作为变量名" class="headerlink" title="default可以作为导出的名字，但是不能作为变量名"></a>default可以作为导出的名字，但是不能作为变量名</h3><p>这就意味着default只能出现在别名导入的左边<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'some_module'</span>;</span><br></pre></td></tr></table></figure></p><p>或则别名导出的右边：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure></p><p>或则再导出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; myFunc <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> otherFunc &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following two statements are equivalent:</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="在使用方，导入的是视图"><a href="#在使用方，导入的是视图" class="headerlink" title="在使用方，导入的是视图"></a>在使用方，导入的是视图</h2><p>CommonJS和ES6导入方面有明显的不同：</p><ul><li>在CommonJS中，导入的值只是导出的一份拷贝</li><li>在ES6中，导入的值是导出值的一个只读视图</li></ul><p>CommonJS环境中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    counter: counter, <span class="comment">// (A)</span></span><br><span class="line">    incCounter: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main1.js ------</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).counter; <span class="comment">// (B)</span></span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value is a (disconnected) copy of a copy</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value can be changed</span></span><br><span class="line">counter++;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>ES6环境中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main1.js ------</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value `counter` is live</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value can’t be changed</span></span><br><span class="line">counter++; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p><p>使用*导入也一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ main2.js ------</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value `counter` is live</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.counter); <span class="comment">// 3</span></span><br><span class="line">lib.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(lib.counter); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value can’t be changed</span></span><br><span class="line">lib.counter++; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p><p>但是有一点需要注意的是不能修改导入的对象，但是可以修改对象引用的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习：概念</title>
      <link href="/2017/08/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/08/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p><code>机器学习</code>很火。火到什么程度？火到国家都出台政策，说要到XXXX年“赶英超美”。网络上也是充满了关于<code>机器学习</code>的言论，当然也包括一些末日论。作为一个技术人员，不应该只看这种表面性的、具有很大宣传性质的信息。本着一颗好奇心，也接触下<code>机器学习</code>。但是作为新闻性质的文章，它都是基于一些特定的假设之上。很难让初学者理出一个头绪。比如一上来就跟你谈<code>深度学习</code>，谈<code>感知机</code>，谈<code>神经网络</code>，那么没几下就会被绕晕。</p><p>所以想从基础性的概念入手，一步一步构建，而不是之谈及那些平常人听不懂的<code>高大上</code>的名词。</p><p><code>机器学习</code>不是新概念，几十年前就有了，为什么最近几年会火？原因有两个：</p><ul><li>人类文明社会的数字化程度越来越高</li><li>计算机的高速发展</li></ul><p>数字化程度越来越高的意思是社会的各个行业都离不开计算机，都会产生大量的数据。这就是机器学习天生的<code>训练数据</code>（当然并不是所有的都是可用的）。而计算机的高速发展，带来的效果就是处理能力越来越强。这两者结合，以及一些算法上的创新，导致机器学习又迎来了人生的第三春。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>下面简单介绍一些<code>机器学习</code>方面用到的基本术语。</p><h3 id="示例（instance）或-样本（sample）"><a href="#示例（instance）或-样本（sample）" class="headerlink" title="示例（instance）或 样本（sample）"></a><strong>示例（instance）或 样本（sample）</strong></h3><p>每一条数据或者称为记录，都是关于一个事件或者对象（比如一个西瓜）的描述。这样的一个记录称之为一个“示例”（instance）或者“样本”（sample）。</p><hr><h3 id="数据集（data-set）"><a href="#数据集（data-set）" class="headerlink" title="数据集（data set）"></a><strong>数据集（data set）</strong></h3><p>记录的集合。</p><hr><h3 id="属性（attribute）或-特征（feature）"><a href="#属性（attribute）或-特征（feature）" class="headerlink" title="属性（attribute）或 特征（feature）"></a><strong>属性（attribute）或 特征（feature）</strong></h3><p>样本的特定方面的描述，称之为 <strong>属性</strong>，比如西瓜的颜色等。</p><hr><h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a><strong>属性值</strong></h3><p>属性上的取值称之为属性值，比如青绿。</p><hr><h3 id="属性空间（attribute-space）、样本空间（sample-space）、输入空间"><a href="#属性空间（attribute-space）、样本空间（sample-space）、输入空间" class="headerlink" title="属性空间（attribute space）、样本空间（sample space）、输入空间"></a><strong>属性空间（attribute space）、样本空间（sample space）、输入空间</strong></h3><p>样本上的所有属性张成的空间称之为属性空间。比如色泽”，“根蒂”，“敲声”作为描述西瓜的三个属性的三个坐标轴，则它们张成一个描述西瓜的 <strong>三维空间</strong>，每个西瓜都可以在这个空间中找到自己的坐标位置。这里属性的个数称之为样本的 <strong>维数</strong>。</p><hr><h3 id="学习（learning）或-训练（training）"><a href="#学习（learning）或-训练（training）" class="headerlink" title="学习（learning）或 训练（training）"></a><strong>学习（learning）或 训练（training）</strong></h3><p>从数据中学得模型的过程称之为 <strong>学习</strong> 或 <strong>训练</strong>。训练过程中使用的数据称之为 <strong>训练数据（training data）</strong>，其中每一个样本称之为 <strong>训练样本（training sample）</strong>。训练样本组成的集合称之为 <strong>训练集（training set）</strong>。</p><hr><h3 id="假设（hypothesis）"><a href="#假设（hypothesis）" class="headerlink" title="假设（hypothesis）"></a><strong>假设（hypothesis）</strong></h3><p>学得模型对应了关于数据的某种潜在的规律，这种规律称之为 <strong>假设</strong>，这种潜在规律的自身，称之为 <strong>真相（ground-truth）</strong>。<strong>学习的过程就是为了找出或者逼近真相</strong>。</p><hr><h3 id="学习器（learner）"><a href="#学习器（learner）" class="headerlink" title="学习器（learner）"></a><strong>学习器（learner）</strong></h3><p>学习算法在给定的数据和参数空间上的实例化称之为 <strong>学习器</strong>。</p><hr><h3 id="标记（label）与样例（example）"><a href="#标记（label）与样例（example）" class="headerlink" title="标记（label）与样例（example）"></a><strong>标记（label）与样例（example）</strong></h3><p>在对数据进行“预测（prediction）”的时候，需要训练样本的“结果”信息。比如三个属性分别如何才是一个“好瓜”。这里的示例结果的信息，例如“好瓜”，称之为 <strong>标记（label）</strong>。拥有标记信息的示例，称之为 <strong>样例（example）</strong>。所有的标记的集合，称之为 <strong>标记空间（label space）</strong>。</p><hr><h3 id="分类（classification）、回归（regression）、聚类（clustering）"><a href="#分类（classification）、回归（regression）、聚类（clustering）" class="headerlink" title="分类（classification）、回归（regression）、聚类（clustering）"></a><strong>分类（classification）、回归（regression）、聚类（clustering）</strong></h3><p>如果预测的是离散值，则此类学习任务成为 <strong>分类</strong>；若预测的是连续值，则此类学习任务称之为 <strong>_回归</strong>。如果对训练数据分成若干组，每组称之为一个 <strong>簇（cluster）</strong>，这些自动形成的簇可能对应一些潜在的概念划分。如果对西瓜划分，可能区分为“浅色瓜”，“深色瓜”或者“本地瓜”，“外地瓜”等。在学习之前，这些分类都是不知道的，而且通常训练样本不具备标记信息。这样的学习任务称之为 <strong>聚类</strong>。</p><p>涉及到两个类别的学习任务分类称之为 <strong>二分类</strong> 任务，其中一个类称之为 <strong>正类（positive class）</strong>，另一个类称之为 <strong>反类（negative class）</strong>。</p><hr><h3 id="监督学习（supervised-learning）与无监督学习（unsupervised-learning）"><a href="#监督学习（supervised-learning）与无监督学习（unsupervised-learning）" class="headerlink" title="监督学习（supervised learning）与无监督学习（unsupervised learning）"></a><strong>监督学习（supervised learning）与无监督学习（unsupervised learning）</strong></h3><p>训练数据有标记信息的学习任务称之为 <strong>监督学习</strong>，包括 <strong>分类</strong> 和 <strong>回归</strong>。<br>训练数据没有标记信息的学习任务称之为 <strong>无监督学习</strong>，包括 <strong>聚类</strong>。</p><hr><h3 id="归纳学习（inductive-learning）"><a href="#归纳学习（inductive-learning）" class="headerlink" title="归纳学习（inductive learning）"></a><strong>归纳学习（inductive learning）</strong></h3><p>归纳（induction）指的是，从特殊到一般的“泛化（generalization）”过程，即从具体的事实归结出一般性规律。演绎（deduction）指的是，从一般到特殊的“特化（specialization）”过程，即从基础原理推演出具体状况。</p><p>“从样例中学习”显然是一个归纳的过程，因此也称为 <strong>归纳学习</strong>。习得模型适用于新样本的能力，称之为 <strong>泛化能力</strong>。归纳学习有 <strong>狭义</strong> 和 <strong>广义</strong> 之分。狭义的归纳学习大体相当于从样例中学习；广义的归纳学习则要求从训练数据中学得 <strong>概念（concept）</strong>，因此亦称为 <strong>概念学习</strong>。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 6 unique_ptr</title>
      <link href="/2017/07/29/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%206%20unique_ptr/"/>
      <url>/2017/07/29/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%206%20unique_ptr/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/c11-unique_ptr-tutorial-and-examples/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><h1 id="什么是std-unique-ptr？"><a href="#什么是std-unique-ptr？" class="headerlink" title="什么是std::unique_ptr？"></a>什么是<code>std::unique_ptr</code>？</h1><p>智能指针出了<code>std::shared_ptr</code>，还包括另外一种<code>std::unique_ptr</code>。<code>std::unique_ptr</code>与<code>std::shared_ptr</code>功能一样，除了<code>std::unique_ptr</code>是独占资源所有权。意思是<code>std::unique_ptr</code>对象不能与其他的<code>std::unique_ptr</code>对象共享资源。<code>std::unique_ptr</code>也接受一个裸指针来创建对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mId;</span><br><span class="line">Task(<span class="keyword">int</span> id ) :mId(id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Task::Constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Task()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Task::Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create a unique_ptr object through raw pointer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr(<span class="keyword">new</span> Task(<span class="number">23</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Access the element through unique_ptr</span></span><br><span class="line"><span class="keyword">int</span> id = taskPtr-&gt;mId;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task::Constructor</span><br><span class="line"><span class="number">23</span></span><br><span class="line">Task::Destructor</span><br></pre></td></tr></table></figure></p><p><code>std::unique_ptr</code>对象<code>taskPtr</code>接收一个裸指针作为参数。当函数退出时，<code>taskPtr</code>对象会超出作用域，析构函数会被调用。在析构函数中，<code>taskPtr</code>会删除与之相关的裸指针。</p><p>不管函数是正常退出还是异常退出，<code>taskPtr</code>的析构函数都会被调用。因此不会造成内存泄漏的情况。</p><h1 id="unique指针的独享所有权"><a href="#unique指针的独享所有权" class="headerlink" title="unique指针的独享所有权"></a>unique指针的独享所有权</h1><p>独享所有权的意思是无法拷贝<code>std::unique_ptr</code>对象。只能<code>move</code>。每一个<code>std::unique_ptr</code>对象都只是裸指针的唯一拥有者，所有<code>std::unique_ptr</code>对象内部无需管理引用计数。</p><h1 id="创建一个空的std-unique-ptr对象"><a href="#创建一个空的std-unique-ptr对象" class="headerlink" title="创建一个空的std::unique_ptr对象"></a>创建一个空的<code>std::unique_ptr</code>对象</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空的`std::unique_ptr`对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1;</span><br></pre></td></tr></table></figure><p>因为没有裸指针与之关联，所以<code>ptr1</code>是空的。</p><h1 id="检查std-unique-ptr对象是否为空"><a href="#检查std-unique-ptr对象是否为空" class="headerlink" title="检查std::unique_ptr对象是否为空"></a>检查<code>std::unique_ptr</code>对象是否为空</h1><p>方法1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ptr1)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr1 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>方法2：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr1 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr1 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h1 id="使用裸指针创建std-unique-ptr对象"><a href="#使用裸指针创建std-unique-ptr对象" class="headerlink" title="使用裸指针创建std::unique_ptr对象"></a>使用裸指针创建<code>std::unique_ptr</code>对象</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr(<span class="keyword">new</span> Task(<span class="number">23</span>));</span><br></pre></td></tr></table></figure><p>不能通过赋值的方式来创建<code>std::unique_ptr</code>对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2 = <span class="keyword">new</span> Task(); <span class="comment">// Compile Error</span></span><br></pre></td></tr></table></figure></p><h1 id="重置std-unique-ptr对象"><a href="#重置std-unique-ptr对象" class="headerlink" title="重置std::unique_ptr对象"></a>重置<code>std::unique_ptr</code>对象</h1><p>调用<code>reset()</code>函数会导致<code>std::unique_ptr</code>对象被重置，也就是与之关联的裸指针会被删除，同时<code>std::unique_ptr</code>对象会被置空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskPtr.reset();</span><br></pre></td></tr></table></figure></p><h1 id="std-unique-ptr对象无法被拷贝"><a href="#std-unique-ptr对象无法被拷贝" class="headerlink" title="std::unique_ptr对象无法被拷贝"></a><code>std::unique_ptr</code>对象无法被拷贝</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 `unique_ptr` 对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr3 = taskPtr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line">taskPtr = taskPtr2;</span><br></pre></td></tr></table></figure><h1 id="转移std-unique-ptr对象所有权"><a href="#转移std-unique-ptr对象所有权" class="headerlink" title="转移std::unique_ptr对象所有权"></a>转移<code>std::unique_ptr</code>对象所有权</h1><p>无法拷贝<code>std::unique_ptr</code>对象，但是可以转移<code>std::unique_ptr</code>对象的所有权。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr4 = <span class="built_in">std</span>::move(taskPtr2);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(taskPtr2 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr2 is  empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `taskPtr2`的所有权被转移到 `taskPtr4`对象</span></span><br><span class="line"><span class="keyword">if</span>(taskPtr4 != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr4 is not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;taskPtr4-&gt;mId&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p><code>taskPtr2</code>对象在转移所有权后会被置为空。</p><h1 id="释放裸指针"><a href="#释放裸指针" class="headerlink" title="释放裸指针"></a>释放裸指针</h1><p>通过调用<code>release()</code>函数，可以从<code>std::unique_ptr</code>对象中将裸指针释放出来，它返回一个裸指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr5(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(taskPtr5 != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr5 is not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">Task * ptr = taskPtr5.release();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(taskPtr5 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr5 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>完整例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mId;</span><br><span class="line">Task(<span class="keyword">int</span> id ) :mId(id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Task::Constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Task()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Task::Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Empty unique_ptr object</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if unique pointer object is empty</span></span><br><span class="line"><span class="keyword">if</span>(!ptr1)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr1 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if unique pointer object is empty</span></span><br><span class="line"><span class="keyword">if</span>(ptr1 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr1 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can not create unique_ptr object by initializing through assignment</span></span><br><span class="line"><span class="comment">// std::unique_ptr&lt;Task&gt; taskPtr2 = new Task(); // Compile Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a unique_ptr object through raw pointer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr(<span class="keyword">new</span> Task(<span class="number">23</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if taskPtr is empty or it has an associated raw pointer</span></span><br><span class="line"><span class="keyword">if</span>(taskPtr != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr is  not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Access the element through unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;taskPtr-&gt;mId&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Reset the taskPtr"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// Reseting the unique_ptr will delete the associated</span></span><br><span class="line"><span class="comment">// raw pointer and make unique_ptr object empty</span></span><br><span class="line">taskPtr.reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if taskPtr is empty or it has an associated raw pointer</span></span><br><span class="line"><span class="keyword">if</span>(taskPtr == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr is  empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a unique_ptr object through raw pointer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(taskPtr2 != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr2 is  not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_ptr object is Not copyable</span></span><br><span class="line"><span class="comment">//taskPtr = taskPtr2; //compile error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_ptr object is Not copyable</span></span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Task&gt; taskPtr3 = taskPtr2;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Transfer the ownership</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr4 = <span class="built_in">std</span>::move(taskPtr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(taskPtr2 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr2 is  empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ownership of taskPtr2 is transfered to taskPtr4</span></span><br><span class="line"><span class="keyword">if</span>(taskPtr4 != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr4 is not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;taskPtr4-&gt;mId&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//taskPtr4 goes out of scope and deletes the assocaited raw pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a unique_ptr object through raw pointer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr5(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(taskPtr5 != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr5 is not empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the ownership of object from raw pointer</span></span><br><span class="line">Task * ptr = taskPtr5.release();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(taskPtr5 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"taskPtr5 is empty"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ptr-&gt;mId&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ptr1 is empty</span><br><span class="line">ptr1 is empty</span><br><span class="line">Task::Constructor</span><br><span class="line">taskPtr is  <span class="keyword">not</span> empty</span><br><span class="line"><span class="number">23</span></span><br><span class="line">Reset the taskPtr</span><br><span class="line">Task::Destructor</span><br><span class="line">taskPtr is  empty</span><br><span class="line">Task::Constructor</span><br><span class="line">taskPtr2 is  <span class="keyword">not</span> empty</span><br><span class="line">taskPtr2 is  empty</span><br><span class="line">taskPtr4 is <span class="keyword">not</span> empty</span><br><span class="line"><span class="number">55</span></span><br><span class="line">Task::Destructor</span><br><span class="line">Task::Constructor</span><br><span class="line">taskPtr5 is <span class="keyword">not</span> empty</span><br><span class="line">taskPtr5 is empty</span><br><span class="line"><span class="number">55</span></span><br><span class="line">Task::Destructor</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 5 shared_ptr与循环引用</title>
      <link href="/2017/07/26/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%205%20shared_ptr%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
      <url>/2017/07/26/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%205%20shared_ptr%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/shared_ptr-binary-trees-and-the-problem-of-cyclic-references/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><p>使用智能指针的主要优点是能够在合适的时间来释放相关的内存。但是使用不当也会将这个主要优点变成缺点。</p><p>假设我们要实现一个二叉树，用左右两个指针来保存孩子节点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line">Node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; leftPtr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; rightPtr;</span><br><span class="line">    Node(<span class="keyword">int</span> val) : value(val) &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Contructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node() &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后可以这么使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    ptr-&gt;leftPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    ptr-&gt;rightPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后在控制台会输出三次构造和三次析构。完全按照我们想要的执行。<br><img src="normal.PNG" alt="正常"></p><p>但是此时如果想要增加一个小需求，也就是每个节点保存父节点。我们可能会想到这样做：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; leftPtr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; rightPtr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; parentPtr;</span><br><span class="line">    Node(<span class="keyword">int</span> val) : value(val)     &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Contructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()     &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后这样使用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    ptr-&gt;leftPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    ptr-&gt;leftPtr-&gt;parentPtr = ptr;</span><br><span class="line">    ptr-&gt;rightPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    ptr-&gt;rightPtr-&gt;parentPtr = ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr reference count = "</span>&lt;&lt;ptr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;leftPtr reference count = "</span>&lt;&lt;ptr-&gt;leftPtr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;rightPtr reference count = "</span>&lt;&lt;ptr-&gt;rightPtr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是此时在控制台输出中，只看到了三次构造，没有析构。<br><img src="leak.PNG" alt="内存泄漏"></p><p>原因是这里引入了循环依赖。<code>shared_ptr</code>对象释放内存的条件是内部引用计数为0。上述的例子中，<code>ptr</code>对象的内部引用计数不可能为0。分析一下。</p><p>当<code>ptr</code>析构被调用：</p><ul><li>引用计数减1</li><li>检查引用计数的值是否为0，但实际上为2，因为被左右子节点引用了</li><li>左右子节点只有在<code>ptr</code>对象被正确删除后才会被删除，但是此时<code>ptr</code>的引用计数一直大于0，所以不会被删除</li><li>最终，<code>ptr</code>和子节点的内存都没有被删除，因此没有析构被调用</li></ul><p>解决此问题的办法是使用<code>weak_ptr</code>。<code>weak_ptr</code>只能对资源共享，也就是会增加内部的引用计数，但是不会对实际资源进行引用。因此<code>weak_ptr</code>对象不能使用操作符<code>*</code>和<code>-&gt;</code>来访问相关的资源。只能通过调用<code>lock()</code>函数来创建<code>shared_ptr</code>对象来操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weakPtr(ptr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_2 =  weakPtr.lock();</span><br><span class="line">    <span class="keyword">if</span>(ptr_2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(*ptr_2)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Reference Count :: "</span>&lt;&lt;ptr_2.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">if</span>(weakPtr.expired() == <span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Not expired yet"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><img src="weak_ptr.PNG" alt="weak_ptr"></p><p>这里有个需要注意的是，<code>lock</code>函数可能返回空的<code>shared_ptr</code>对象。</p><p>将我们的<code>Node</code>的<code>parentPtr</code>类型修改成<code>weak_ptr</code>即可解决循环引用的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; leftPtr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; rightPtr;</span><br><span class="line">    <span class="comment">// Just Changed the shared_ptr to weak_ptr</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Node&gt; parentPtr;</span><br><span class="line">    Node(<span class="keyword">int</span> val) : value(val)     &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Contructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()     &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Node&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">4</span>);</span><br><span class="line">    ptr-&gt;leftPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">2</span>);</span><br><span class="line">    ptr-&gt;leftPtr-&gt;parentPtr = ptr;</span><br><span class="line">    ptr-&gt;rightPtr = <span class="built_in">std</span>::make_shared&lt;Node&gt;(<span class="number">5</span>);</span><br><span class="line">    ptr-&gt;rightPtr-&gt;parentPtr = ptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr reference count = "</span>&lt;&lt;ptr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;leftPtr reference count = "</span>&lt;&lt;ptr-&gt;leftPtr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;rightPtr reference count = "</span>&lt;&lt;ptr-&gt;rightPtr.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;rightPtr-&gt;parentPtr reference count = "</span>&lt;&lt;ptr-&gt;rightPtr-&gt;parentPtr.lock().use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr-&gt;leftPtr-&gt;parentPtr reference count = "</span>&lt;&lt;ptr-&gt;leftPtr-&gt;parentPtr.lock().use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><img src="weak_ptr2.PNG" alt="weak_ptr"></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 4 小心创建shared_ptr对象</title>
      <link href="/2017/07/23/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%204%20%E5%B0%8F%E5%BF%83%E5%88%9B%E5%BB%BAshared_ptr%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/07/23/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%204%20%E5%B0%8F%E5%BF%83%E5%88%9B%E5%BB%BAshared_ptr%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/create-shared_ptr-objects-carefully/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><p>在创建<code>shared_ptr</code>对象时应该要注意两点：</p><ol><li>不要使用裸指针来创建两个以上的<code>shared_ptr</code>对象</li><li>不要从栈内存上创建<code>shared_ptr</code>对象</li></ol><h1 id="不要使用裸指针来创建两个以上的shared-ptr对象"><a href="#不要使用裸指针来创建两个以上的shared-ptr对象" class="headerlink" title="不要使用裸指针来创建两个以上的shared_ptr对象"></a>不要使用裸指针来创建两个以上的<code>shared_ptr</code>对象</h1><p>因为每个<code>shared_ptr</code>对象是不清楚其他的<code>shared_ptr</code>对象与其共享了裸指针对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * rawPtr = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_1(rawPtr);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_2(rawPtr);</span><br></pre></td></tr></table></figure></p><p>当其中之一超过作用域范围，那么就会删除与其相关的裸指针对象。这样一来就导致了另外的<code>shared_ptr</code>对象指向的裸指针变成了悬挂指针（dangling pointer），当期超出作用域时，再次删除内部裸指针就会导致程序崩溃。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sample</span> &#123;</span></span><br><span class="line">Sample() &#123;</span><br><span class="line">    internalValue = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Sample() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Sample;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    Sample * rawPtr = <span class="keyword">new</span> Sample();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr_1(rawPtr);</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr_2(rawPtr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 因为`ptr_2`不知道相同的裸指针也被用在了其他的`shared_ptr`对象上，因此当`ptr_2`超出作用域后，会将其相关联的裸指针删除。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此时，`ptr_1`内部关联的是一个悬挂指针。因此当其超出作用域后会试图去删除一个已被删掉的裸指针，程序崩溃。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="不要从栈内存上创建shared-ptr对象"><a href="#不要从栈内存上创建shared-ptr对象" class="headerlink" title="不要从栈内存上创建shared_ptr对象"></a>不要从栈内存上创建<code>shared_ptr</code>对象</h1><p>看下下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr(&amp;x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>shared_ptr</code>对象所预期的内存是从堆上开辟的，因此在其超出作用域后，如果引用计数为0就会从堆上删除。而上面的代码中可以看到，<code>shared_ptr</code>对象相关联的内存是在栈上，因此当其超出作用域试图删除相关的内存时，会导致程序崩溃。</p><p>正确创建<code>shared_ptr</code>对象不是从裸指针，而是使用<code>make_shared&lt;&gt;</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_1 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_2 (ptr_1);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 3 shared_ptr vs 指针</title>
      <link href="/2017/07/22/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%203%20shared_ptr%20vs%20%E6%8C%87%E9%92%88/"/>
      <url>/2017/07/22/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%203%20shared_ptr%20vs%20%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/how-shared_ptr-object-is-different-from-a-raw-pointer/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><p>我们从以下几个方面对<code>shared_ptr</code>对象和裸指针进行比较。</p><h1 id="缺失-，–-和-操作符"><a href="#缺失-，–-和-操作符" class="headerlink" title="缺失 ++，– 和 [] 操作符"></a>缺失 ++，– 和 [] 操作符</h1><p>和裸指针相比，<code>shared_ptr</code>对象只提供以下操作符：</p><ul><li>-&gt;, *</li><li>比较操作符</li></ul><p>不提供以下：</p><ul><li>算数运算，比如：+，-，++，–</li><li>[]操作符</li></ul><p>看下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dummyFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"dummyFunction"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Sample&gt;();</span><br><span class="line"></span><br><span class="line">(*ptr).dummyFunction(); <span class="comment">// Will Work</span></span><br><span class="line"></span><br><span class="line">ptr-&gt;dummyFunction(); <span class="comment">// Will Work</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ptr[0]-&gt;dummyFunction(); // 编译会失败。</span></span><br><span class="line"><span class="comment">// ptr++;  // 编译会失败。</span></span><br><span class="line"><span class="comment">//ptr--;  // 编译会失败。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr2(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr == ptr2) <span class="comment">// 能运行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr and ptr2 are equal"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dummyFunction</span><br><span class="line">dummyFunction</span><br><span class="line">ptr <span class="keyword">and</span> ptr2 are equal</span><br></pre></td></tr></table></figure></p><h1 id="NULL-检查"><a href="#NULL-检查" class="headerlink" title="NULL 检查"></a>NULL 检查</h1><p>创建一个<code>shared_ptr</code>对象而不对其赋值，那么它就是空的。然而，如果我们创建一个裸指针而不对其赋值，那么它有可能是指向一个垃圾内存地址，同时我们又没办法去验证它所指的内存地址是垃圾地址还是有效地址。</p><p>我们可以对<code>shared_ptr</code>进行这样的检测：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr3;</span><br><span class="line"><span class="keyword">if</span>(!ptr3)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes, ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>也可以访问<code>shared_ptr</code>内部的裸指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr = <span class="built_in">std</span>::make_shared&lt;Sample&gt;();</span><br><span class="line">Sample * rawptr = ptr.get();</span><br></pre></td></tr></table></figure></p><p>但是通常不建议这么做。因为如果将内部的指针取出后进行删除，当<code>shared_ptr</code>超出作用域同时引用计数为0时再次删除内部的资源时会导致程序崩溃。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 2 shared_ptr 和自定义Deleter</title>
      <link href="/2017/07/19/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%202%20shared_ptr%20%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Deleter/"/>
      <url>/2017/07/19/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%202%20shared_ptr%20%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Deleter/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/shared_ptr-and-custom-deletor/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><p><a href="http://codingwith.me/2017/07/16/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%201%20shared_ptr%20%E6%95%99%E7%A8%8B%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/">上一篇</a>讲述了<code>std::shared_ptr</code>的基本用法。这一篇讲述的是相关的deleter。当<code>std::shared</code>对象超出作用域范围时，会自动调用析构函数，当引用计数为0时，会删除相关的裸指针，也就是如何使用自定义的deleter来删除<code>std::shared</code>引用的裸指针对象。</p><p>通常情况下是直接调用delete。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pointer;</span><br></pre></td></tr></table></figure></p><p>但是当<br><strong><code>shared_ptr</code>指向的是数组对象时</strong>，情况就不同了。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>]);</span><br></pre></td></tr></table></figure></p><p>此时如果还是使用默认的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p3;</span><br></pre></td></tr></table></figure></p><p>明显会导致内存泄漏，正确的是应该使用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []p3;</span><br></pre></td></tr></table></figure></p><p>上述的deleter是在构造<code></code>std::shared_ptr`对象时，指定的deleter，通常我们可以自定义，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(Sample * x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DELETER FUNCTION CALLED\n"</span>;</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再传入<code>std::shared_ptr</code>构造函数中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p3(<span class="keyword">new</span> Sample[<span class="number">12</span>], deleter);</span><br></pre></td></tr></table></figure></p><p>下面是完整的例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Sample()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CONSTRUCTOR\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Sample()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DESTRUCTOR\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// deleter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(Sample * x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DELETER FUNCTION CALLED\n"</span>;</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p3(<span class="keyword">new</span> Sample[<span class="number">12</span>], deleter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">CONSTRUCTOR</span><br><span class="line">DELETER FUNCTION CALLED</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br><span class="line">DESTRUCTOR</span><br></pre></td></tr></table></figure></p><p>作为deleter不仅仅只有上述一种函数的形式，还包括Lambda函数和函数对象。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Sample * x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"DELETER FUNCTION CALLED\n"</span>;</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数对象作为 deleter</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p3(<span class="keyword">new</span> Sample[<span class="number">12</span>], Deleter());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Lambda函数作为 deleter</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p4(<span class="keyword">new</span> Sample[<span class="number">12</span>], [](Sample * x)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"DELETER FUNCTION CALLED\n"</span>;</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>还有一种情况是，在使用资源池的情况下，无需真的释放内存块，而只是将内存或者资源返回给资源池。比如下面这个仿真内存池：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Memory Pool Dummy Kind of Implementation</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T * <span class="title">AquireMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AQUIRING MEMORY\n"</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">new</span> T());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseMemory</span><span class="params">(T * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"RELEASE MEMORY\n"</span>;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MemoryPool&lt;Sample&gt; &gt; memoryPoolPtr = <span class="built_in">std</span>::make_shared&lt;</span><br><span class="line">MemoryPool&lt;Sample&gt; &gt;();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p3(memoryPoolPtr-&gt;AquireMemory(),</span><br><span class="line"><span class="built_in">std</span>::bind(&amp;MemoryPool&lt;Sample&gt;::ReleaseMemory, memoryPoolPtr,</span><br><span class="line"><span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AMD R5 340X显卡驱动问题</title>
      <link href="/2017/07/19/AMD-R5-340X%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/19/AMD-R5-340X%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>AMD Radeon R5 340X显卡在更新了最新的Redeon驱动后，无法在windows中显示正确的分辨率，最高为<code>1600*1200</code>。显示器为Dell E22110H（老古董了，正常的分辨率应该为<code>1920*1080</code>）</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在网上搜索了下，找到了个Dell的关于Optiplex 5040驱动<a href="http://zh.community.dell.com/support_forums/desktops/f/236/t/14252" target="_blank" rel="noopener">下载页面</a>。下载了对应的win10版本后安装，重启后还是无法显示正确的分辨率，可选的分辨率没有变。后来在CCC.exe（原来的催化剂！现在变成了Radeon的附加设置）中，在VGA显示器中属性节点页面的监视器特性中，有个可以设置最大分辨率的下拉框。而在Radeon的主程序中，什么都没显示，也无任何地方可以设置，除了中间那个最大的广告！（我还是喜欢催化剂，直观地显示了对显示器的控制，让用户能够清晰简单地操作设备）</p><p>在这个下拉框中选择了<code>1920*1080</code>，刷新率为60Hz。在系统设置的显示里终于显示了<code>1920*1080</code>的选项。</p><blockquote><p>2017-7-23 更新</p></blockquote><blockquote><p>在最新的Radeon的主页中，有个<code>显示器</code>选项中，有个自定义修改分辨率，也可通过这个手动来增加一个自定义的设置，设置中增加显示器的最佳分辨率。</p></blockquote><blockquote><p>PS 这个设置之前也用过，但是没生效。最近一次自定义后，突然发现又生效了。可能是和显卡驱动的版本有关。这次是更新到最新了。</p></blockquote><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>首先不吐槽这个显卡有多么低端。对于AMD对于低端显卡的支持以及配置的易用性真是不敢恭维。在可以自主选择的情况下，对于AMD的显卡基本不在选择列中。</p><hr><p>在处理显卡的问题过程中，还将原来的那台OptiPlex 980MT的显卡拆下来装到5040上，事后当然又拆回去了。在这个过程当中，发现Dell主机的模块化做的是越来越好了。拆卸5040基本都不用工具，前提是要知道方法。而980MT却还需要借助工具才能将部件拆下来。5040有一个需要注意的是内存电压是1.35v的。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++11 智能指针 – Part 1 shared_ptr 教程和示例代码</title>
      <link href="/2017/07/16/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%201%20shared_ptr%20%E6%95%99%E7%A8%8B%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/07/16/C++11%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E2%80%93%20Part%201%20shared_ptr%20%E6%95%99%E7%A8%8B%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><a href="http://thispointer.com/learning-shared_ptr-part-1-usage-details/" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>译注： 本翻译只遵循文章要表达的意图，而不会逐句翻译。</p></blockquote><blockquote><p>这个是一系列关于智能指针的文章，谈及的东西都是比较入门的介绍。</p></blockquote><h1 id="什么是std-shared-ptr-lt-gt"><a href="#什么是std-shared-ptr-lt-gt" class="headerlink" title="什么是std::shared_ptr&lt;&gt;"></a>什么是std::shared_ptr&lt;&gt;</h1><p><code>shared_ptr</code>是<code>C++11</code>提供的智能指针的一种。用来在离开作用域的时候，自动删除相关联指针的技术。因此它可以帮助我们处理一些因为疏忽大意而导致的内存泄漏和指针悬挂问题。</p><h1 id="shared-ptr和共享所有权"><a href="#shared-ptr和共享所有权" class="headerlink" title="shared_ptr和共享所有权"></a>shared_ptr和共享所有权</h1><p>谈及<code>shared_ptr</code>就不得不谈及资源所有权的问题。不同的<code>shared_ptr</code>可以关联到t相同的资源指针，内部使用引用计数来进行管理。</p><p><strong>每个<code>shared_ptr</code>对象内部都指向两个内存地址：</strong></p><ul><li>指向资源对象</li><li>指向用于引用计数的数据结构</li></ul><p><strong>共享所有权是如何通过引用计数来实现的？</strong></p><ul><li>当一个新的<code>shared_ptr</code>对象和一个裸指针关联时，在构造函数内会对此裸指针关联的引用计数加1</li><li>当<code>shared_ptr</code>超出作用域时，在其析构函数内，会对其关联的引用计数减1。如果引用计数变为0,也就意味着没有其他的<code>shared_ptr</code>对象和裸指针所指向的内存相关联了，那么就是使用“delete”函数来释放内存空间。</li></ul><h1 id="创建一个shared-ptr对象"><a href="#创建一个shared-ptr对象" class="headerlink" title="创建一个shared_ptr对象"></a>创建一个<code>shared_ptr</code>对象</h1><h2 id="方法1：使用构造"><a href="#方法1：使用构造" class="headerlink" title="方法1：使用构造"></a>方法1：使用构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>());</span><br></pre></td></tr></table></figure><p>上述代码在堆上分配了两块内存：</p><ol><li>对象int</li><li>管理<code>shared_ptr</code>对象的引用计数的内存。初始值为1.</li></ol><p><strong>检查一个<code>shared_ptr</code>对象的引用计数：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.use_count();</span><br></pre></td></tr></table></figure></p><h2 id="方法2：使用std-make-shared"><a href="#方法2：使用std-make-shared" class="headerlink" title="方法2：使用std::make_shared"></a>方法2：使用std::make_shared<t></t></h2><p>不能直接将指针赋值给一个<code>shared_ptr</code>对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compile Error</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// Compile error</span></span><br></pre></td></tr></table></figure></p><p>因为<code>shared_ptr</code>的构造函数式显示接收一个参数,想方法1一样。创建<code>shared_ptr</code>对象最好的方式是通过<code>std::make_shared</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure></p><p>好处是<code>std::make_ptr</code>只会分配一个内存块,也就是 new operator只会调用一次。</p><h2 id="从裸指针分离"><a href="#从裸指针分离" class="headerlink" title="从裸指针分离"></a>从裸指针分离</h2><p>使用<code>reset()</code>函数会使<code>shared_ptr</code>对象的引用计数减1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.reset();</span><br></pre></td></tr></table></figure></p><p><code>reset()</code>还有一种用法，就是指向一个新的指针，内部的引用计数会被重置为1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">34</span>));</span><br></pre></td></tr></table></figure></p><p>从裸指针分离的第二个方法是直接赋值为<code>nullptr</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p><p><strong><code>shared_ptr</code>是一个<em>伪</em>指针（psuedo pointer）</strong><br><code>shared_ptr</code>会假装成一个正常的指针。比如我们可用 <code>*</code>和<code>-&gt;</code>来操作<code>shared_ptr</code>对象。</p><p>完整的示例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;memory&gt; // shared_ptr的t头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 通过`make_shared`创建一个`shared_ptr`对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">*p1 = <span class="number">78</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 打印引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 Reference count = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第二个`shared_ptr`对象内部会指向同一个指针，因此引用计数会变成2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 打印引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2 Reference count = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 Reference count = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// `shared_ptr`对象比较</span></span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 and p2 are pointing to same pointer\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Reset p1 "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">p1.reset();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重置 `shared_ptr`对象，此对象内部不再指向裸指针，因此引用计数会变成0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 Reference Count = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重置 `shared_ptr`对象，此对象内部指向一个新的裸指针，因此引用计数会变成1</span></span><br><span class="line"> </span><br><span class="line">p1.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1  Reference Count = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 使用nullptr进行赋值</span></span><br><span class="line">p1 = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1  Reference Count = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!p1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 is NULL"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="number">78</span></span><br><span class="line">p1 Reference count = <span class="number">1</span></span><br><span class="line">p2 Reference count = <span class="number">2</span></span><br><span class="line">p1 Reference count = <span class="number">2</span></span><br><span class="line">p1 <span class="keyword">and</span> p2 are pointing to same pointer</span><br><span class="line">Reset p1 </span><br><span class="line">p1 Reference Count = <span class="number">0</span></span><br><span class="line">p1  Reference Count = <span class="number">1</span></span><br><span class="line">p1  Reference Count = <span class="number">0</span></span><br><span class="line">p1 is <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript入门需要了解的概念</title>
      <link href="/2017/07/08/JavaScript%E5%85%A5%E9%97%A8%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/07/08/JavaScript%E5%85%A5%E9%97%A8%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&ensp;&ensp;&ensp;作为一个一直从事C\C++的程序员来说，进入JavaScript的世界就好像从室内泳池一下子到太平洋的感觉。在C++的世界，一切都比较封闭，你只需要一个文本编辑器，一个编译器或者一个IDE就足够了。然后你就能用你最爱的泳姿“游泳”了。而在JavaScript的世界里，除了前者的文本编辑器，要考虑和了解事情实在是太多了。诸如ES5、ES6、Babel、webpack等，每年都会出现各种框架，各种库，层出不穷，完全可以把人淹没。</p><p>写这篇文章的目的主要是为了记录在自己进入这个圈子里，在这个过程中学习到的一些知识，了解了这些基础知识，可能就会少走一些弯路。</p><h1 id="JavaScript的版本"><a href="#JavaScript的版本" class="headerlink" title="JavaScript的版本"></a>JavaScript的版本</h1><p>&ensp;&ensp;&ensp;不管何种语言，在进入21世纪后，标准化的工作都进行得越来越频繁。举个例子，拿C++来说，C++98，然后是C++03，之后就是C++11、C++14、C++17、C++20。而且标准委员会对于标准化的进程也做出了比较明确的规划。但是标准的制定和现实中各大编译器厂商的实现之间会有一定的鸿沟。</p><p>&ensp;&ensp;&ensp;JavaScript也一样，TC39现在采取的是小步快走的模式，也就是在每一次的标准更新中都只加入少量的特性，但是保持一定的更新频率，而不是一次加入大量的特性，然后好几年更新一次标准。</p><p>&ensp;&ensp;&ensp;JavaScript是业界对这门语言的称呼，而在标准制定过程中，是由ECMA这个机构来负责,确切说是ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。<br>所以目前的主流是ES6，或者称为ES2015。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><blockquote><p>1998年6月，ECMAScript 2.0版发布。</p></blockquote><blockquote><p>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。</p></blockquote><blockquote><p>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。</p></blockquote><blockquote><p>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。</p></blockquote><blockquote><p>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。</p></blockquote><blockquote><p>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。</p></blockquote><blockquote><p>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。</p></blockquote><blockquote><p>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。</p></blockquote><blockquote><p>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。</p></blockquote><p>&ensp;&ensp;&ensp;以上信息来自于来自<a href="http://baike.baidu.com/item/ECMAScript" target="_blank" rel="noopener">百度百科</a></p><p>&ensp;&ensp;&ensp;上面也提及到，标准的制定和标准的实现是两大阵营。JavaScript的标准实现主要是各大浏览器厂商。而浏览器厂商的实现步伐肯定是落后于标准的制定。但是同时开发者又倾向于在源码中使用新的标准特性，但是用新特性编写的代码在脚本运行环境中又不支持，此时就要谈及到Babel了，一个源码到源码（source-to-source）的转译（transpiller）工具了。</p><h1 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h1><p>&ensp;&ensp;&ensp;目前JavaScript的语言定位是通用型语言，也就是说它不仅仅只是运行在浏览器端，它可以运行在服务端（通过Node.js），运行在移动端（通过React Native），同时也可以创建桌面型应用（通过Electron）。在每个不同的平台上，侧重点是不一样的，所以就导致了应用的一些技术也不同，很明显的就是在服务端和浏览器端的模块化管理。</p><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>&ensp;&ensp;&ensp;模块化是每个语言要应用在中大型项目中避免不了的问题。而JavaScript的标准中却迟迟没有对这方面进行标准化。这也就导致了民间出现了很多用于模块化管理的方法或者工具。最常见的也是最主流的有AMD（Asynchronous Module Definition）、CommonJS、UMD（Universal Module Definition）。</p><p>&ensp;&ensp;&ensp;三者间的主要区别是：</p><ul><li>AMD，如其名，是异步加载的，主要用在浏览器端</li><li>CommonJs，则是同步加载的，主要用于服务端，Node环境下</li><li>UMD的目标则是想统一上述两者的语法差异</li></ul><p>&ensp;&ensp;&ensp;通过下面例子来看看AMD和CommonJS的语法上的区别。<br>最初的源码，使用的是ES6规范：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printInfo () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Name: &#123;this.age&#125;, age: &#123;this.age&#125;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;babel默认情况下产生的输出如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123; <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>; descriptor.configurable = <span class="literal">true</span>; <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>; <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor); &#125; &#125; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123; <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; &#125;; &#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> _classCallCheck(<span class="params">instance, Constructor</span>) </span>&#123; <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Person, [&#123;</span><br><span class="line">    key: <span class="string">"printInfo"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Name: &#123;this.age&#125;, age: &#123;this.age&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">exports.default = Person;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;这其实是CommonJS的语法格式。如果想要生成AMD格式的，需要借助babel-plugin-transform-es2015-modules-amd插件。输出如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">"exports"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">exports</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">    value: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> _classCallCheck(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">        descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">      <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">      <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">      _classCallCheck(<span class="keyword">this</span>, Person);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Person, [&#123;</span><br><span class="line">      key: <span class="string">"printInfo"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Name: &#123;this.age&#125;, age: &#123;this.age&#125;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  exports.default = Person;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;随着ES6标准的发布，在ES6中已经原生支持了模块化的功能。所有可以在代码中使用ES6的原生模块化的语法。</p><p>&ensp;&ensp;&ensp;有时我们需要关注产出物的模块管理方式，这样在使用的时候才不会出现各种问题。Babel只做了源码转译的工作，每一个输入文件对应一个输出文件，所以我们需要一个将这些输出文件打包成一个文件的工具，也就是webpack。</p><h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><p>&ensp;&ensp;&ensp;<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个让开发者可以用新特性编写代码，同时又能运行的一个工具。主要是弥补上述提及的新标准和浏览器支持度之间的鸿沟。它的主要设计思想是插件化。</p><p>&ensp;&ensp;&ensp;Babel有几种运行方式：</p><ul><li>命令行的方式，通过babel-cli</li><li>运行在node环境下，通过babel-node</li><li>运行在源码中，通过babel-register</li></ul><p>&ensp;&ensp;&ensp;在上面章节中，我们使用了插件babel-plugin-transform-es2015-modules-amd来生成AMD格式的代码。使用插件的方式可以通过命令行，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel --plugins transform-es2015-modules-amd .\src.js -o dst.js</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;或者也可以使用.babelrc配置文件来进行配置，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-es2015-modules-amd"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;还有一些配置可以参照官方文档。</p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>&ensp;&ensp;&ensp;<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>是个打包工具，同时也会管理模块的依赖关系。是目前比较主流的打包工具。webpack本身也是使用模块化的方法去打包，同时也是插件化的组织方式。具有以下几个特点：</p><ul><li>代码拆分（code splitting）</li><li>静态分析</li><li>模块热替换（Hot Module Replacement）</li></ul><p>&ensp;&ensp;&ensp;打包后的文件可直接被使用。但是同时有一点需要注意的是，就是打包后的文件格式采取的模块化管理方式。为了将bundle适应不同的运行时环境，通过output.libraryTarget选项，webpack支持将bundle打包成不同格式的模块化代码。具体设置可以参考<a href="https://webpack.js.org/configuration/output/#output-librarytarget" target="_blank" rel="noopener">此链接</a>。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript的19个精简语法</title>
      <link href="/2017/06/25/JavaScript%E7%9A%8419%E4%B8%AA%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/06/25/JavaScript%E7%9A%8419%E4%B8%AA%E7%B2%BE%E7%AE%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="三元操作符简短写法"><a href="#三元操作符简短写法" class="headerlink" title="三元操作符简短写法"></a>三元操作符简短写法</h1><p><strong><strong>Longhand:</strong></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> big;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    big = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    big = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> big = x &gt; <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>或者嵌套：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> big = x &gt; <span class="number">10</span> ? <span class="string">" greater 10"</span> : x &lt; <span class="number">5</span> ? <span class="string">"less 5"</span> : <span class="string">"between 5 and 10"</span>;</span><br></pre></td></tr></table></figure></p><p>个人认为最后一个可读性较差，不建议使用。</p><h1 id="短路计算简短写法"><a href="#短路计算简短写法" class="headerlink" title="短路计算简短写法"></a>短路计算简短写法</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable1 !== <span class="literal">null</span> || variable1 !== <span class="literal">undefined</span> || variable1 !== <span class="string">''</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> variable2 = variable1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> variable2 = variable1  || <span class="string">'new'</span>;</span><br></pre></td></tr></table></figure></p><p>这个很厉害了，大部分人都不太清楚，至少我自己也是。但是它确实可以写成这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> variable1;</span><br><span class="line"><span class="keyword">let</span> variable2 = variable1  || <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(variable2 === <span class="string">''</span>); <span class="comment">// prints true</span></span><br><span class="line">variable1 = <span class="string">'foo'</span>;</span><br><span class="line">variable2 = variable1  || <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(variable2); <span class="comment">// prints foo</span></span><br></pre></td></tr></table></figure></p><h1 id="变量声明简短写法"><a href="#变量声明简短写法" class="headerlink" title="变量声明简短写法"></a>变量声明简短写法</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"><span class="keyword">let</span> z = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x, y, z=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><h1 id="If控制语句简短写法"><a href="#If控制语句简短写法" class="headerlink" title="If控制语句简短写法"></a>If控制语句简短写法</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (likeJavaScript === <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (likeJavaScript)</span><br></pre></td></tr></table></figure></p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">if</span> ( a !== <span class="literal">true</span> ) &#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">if</span> ( !a ) &#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="for控制语句简短写法"><a href="#for控制语句简短写法" class="headerlink" title="for控制语句简短写法"></a>for控制语句简短写法</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allImgs.length; i++)</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> allImgs)</span><br></pre></td></tr></table></figure></p><p>对于Array：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArrayElements</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a["</span> + index + <span class="string">"] = "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(logArrayElements);</span><br><span class="line"><span class="comment">// logs:</span></span><br><span class="line"><span class="comment">// a[0] = 2</span></span><br><span class="line"><span class="comment">// a[1] = 5</span></span><br><span class="line"><span class="comment">// a[2] = 9</span></span><br></pre></td></tr></table></figure></p><h1 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dbHost;</span><br><span class="line"><span class="keyword">if</span> (process.env.DB_HOST) &#123;</span><br><span class="line">  dbHost = process.env.DB_HOST;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  dbHost = <span class="string">'localhost'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dbHost = process.env.DB_HOST || <span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p><h1 id="基于十进制的指数"><a href="#基于十进制的指数" class="headerlink" title="基于十进制的指数"></a>基于十进制的指数</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;&#125;</span><br><span class="line"><span class="comment">// All the below will evaluate to true</span></span><br><span class="line"><span class="number">1e0</span> === <span class="number">1</span>;</span><br><span class="line"><span class="number">1e1</span> === <span class="number">10</span>;</span><br><span class="line"><span class="number">1e2</span> === <span class="number">100</span>;</span><br><span class="line"><span class="number">1e3</span> === <span class="number">1000</span>;</span><br><span class="line"><span class="number">1e4</span> === <span class="number">10000</span>;</span><br><span class="line"><span class="number">1e5</span> === <span class="number">100000</span>;</span><br></pre></td></tr></table></figure></p><h1 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h1><p>以下是对于ES6之后的。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>:x, <span class="attr">y</span>:y &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br></pre></td></tr></table></figure></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>这应该属于ES6的语法上的使用</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Loaded'</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">list.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sayHello = <span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello'</span>, name);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Loaded'</span>), <span class="number">2000</span>);</span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item));</span><br></pre></td></tr></table></figure></p><h1 id="隐示返回值"><a href="#隐示返回值" class="headerlink" title="隐示返回值"></a>隐示返回值</h1><p>这也是ES6的箭头函数的语法。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcCircumference</span>(<span class="params">diameter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * diameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calcCircumference = <span class="function"><span class="params">diameter</span> =&gt;</span> (</span><br><span class="line">  <span class="built_in">Math</span>.PI * diameter;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>ES6的支持。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l, w, h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w === <span class="literal">undefined</span>)</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (h === <span class="literal">undefined</span>)</span><br><span class="line">    h = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> l * w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volume = <span class="function">(<span class="params">l, w = <span class="number">3</span>, h = <span class="number">4</span> </span>) =&gt;</span> (l * w * h);</span><br><span class="line">volume(<span class="number">2</span>) <span class="comment">//output: 24</span></span><br></pre></td></tr></table></figure></p><h1 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h1><p>ES6的支持。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> welcome = <span class="string">'You have logged in as '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="string">'http://'</span> + host + <span class="string">':'</span> + port + <span class="string">'/'</span> + database;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> welcome = <span class="string">`You have logged in as <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> db = <span class="string">`http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>/<span class="subst">$&#123;database&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>ES6的支持。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = <span class="built_in">require</span>(<span class="string">'mobx/observable'</span>);</span><br><span class="line"><span class="keyword">const</span> action = <span class="built_in">require</span>(<span class="string">'mobx/action'</span>);</span><br><span class="line"><span class="keyword">const</span> runInAction = <span class="built_in">require</span>(<span class="string">'mobx/runInAction'</span>);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">this</span>.props.store;</span><br><span class="line"><span class="keyword">const</span> form = <span class="keyword">this</span>.props.form;</span><br><span class="line"><span class="keyword">const</span> loading = <span class="keyword">this</span>.props.loading;</span><br><span class="line"><span class="keyword">const</span> errors = <span class="keyword">this</span>.props.errors;</span><br><span class="line"><span class="keyword">const</span> entity = <span class="keyword">this</span>.props.entity;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action, runInAction &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; store, form, loading, errors, entity &#125; = <span class="keyword">this</span>.props;</span><br></pre></td></tr></table></figure></p><h1 id="字符串换行"><a href="#字符串换行" class="headerlink" title="字符串换行"></a>字符串换行</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lorem = <span class="string">'Lorem ipsum dolor sit amet, consectetur\n\t'</span></span><br><span class="line">    + <span class="string">'adipisicing elit, sed do eiusmod tempor incididunt\n\t'</span></span><br><span class="line">    + <span class="string">'ut labore et dolore magna aliqua. Ut enim ad minim\n\t'</span></span><br><span class="line">    + <span class="string">'veniam, quis nostrud exercitation ullamco laboris\n\t'</span></span><br><span class="line">    + <span class="string">'nisi ut aliquip ex ea commodo consequat. Duis aute\n\t'</span></span><br><span class="line">    + <span class="string">'irure dolor in reprehenderit in voluptate velit esse.\n\t'</span></span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lorem = <span class="string">`Lorem ipsum dolor sit amet, consectetur</span></span><br><span class="line"><span class="string">    adipisicing elit, sed do eiusmod tempor incididunt</span></span><br><span class="line"><span class="string">    ut labore et dolore magna aliqua. Ut enim ad minim</span></span><br><span class="line"><span class="string">    veniam, quis nostrud exercitation ullamco laboris</span></span><br><span class="line"><span class="string">    nisi ut aliquip ex ea commodo consequat. Duis aute</span></span><br><span class="line"><span class="string">    irure dolor in reprehenderit in voluptate velit esse.`</span></span><br></pre></td></tr></table></figure></p><h1 id="…操作符"><a href="#…操作符" class="headerlink" title="…操作符"></a>…操作符</h1><p>ES6的支持。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// joining arrays</span></span><br><span class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">2</span> ,<span class="number">4</span> , <span class="number">6</span>].concat(odd);</span><br><span class="line"><span class="comment">// cloning arrays</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.slice()</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// joining arrays</span></span><br><span class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ];</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">2</span> ,<span class="number">4</span> , <span class="number">6</span>, ...odd];</span><br><span class="line"><span class="built_in">console</span>.log(nums); <span class="comment">// [ 2, 4, 6, 1, 3, 5 ]</span></span><br><span class="line"><span class="comment">// cloning arrays</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr];</span><br></pre></td></tr></table></figure></p><p>或者这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> odd = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ];</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">2</span>, ...odd, <span class="number">4</span> , <span class="number">6</span>];</span><br></pre></td></tr></table></figure></p><p>这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, b, ...z &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(z) <span class="comment">// &#123; c: 3, d: 4 &#125;</span></span><br></pre></td></tr></table></figure></p><p>在ES6之前可能就要用到Array.concat和Object.Assign，但是没那么方便。</p><h1 id="强制参数"><a href="#强制参数" class="headerlink" title="强制参数"></a>强制参数</h1><p>默认情况下，如果没有对函数的参数传入值，JavaScript将函数的参数设置为undefined，所以很多情况下会对函数的参数<br>进行检测。</p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bar === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mandatory = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function">(<span class="params">bar = mandatory(</span>)) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.find</span><br></pre></td></tr></table></figure></p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'Dog'</span>, <span class="attr">name</span>: <span class="string">'Max'</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'Cat'</span>, <span class="attr">name</span>: <span class="string">'Karl'</span>&#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'Dog'</span>, <span class="attr">name</span>: <span class="string">'Tommy'</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;pets.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pets[i].type === <span class="string">'Dog'</span> &amp;&amp; pets[i].name === name) &#123;</span><br><span class="line">      <span class="keyword">return</span> pets[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pet = pets.find(<span class="function"><span class="params">pet</span> =&gt;</span> pet.type ===<span class="string">'Dog'</span> &amp;&amp; pet.name === <span class="string">'Tommy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pet); <span class="comment">// &#123; type: 'Dog', name: 'Tommy' &#125;</span></span><br><span class="line">Obejct[key]</span><br></pre></td></tr></table></figure></p><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!values.first)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(!values.last)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(validate(&#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>,<span class="attr">last</span>:<span class="string">'Wayne'</span>&#125;)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object validation rules</span></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">  first: &#123;</span><br><span class="line">    required:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  last: &#123;</span><br><span class="line">    required:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// universal validation function</span></span><br><span class="line"><span class="keyword">const</span> validate = <span class="function">(<span class="params">schema, values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(field <span class="keyword">in</span> schema) &#123;</span><br><span class="line">    <span class="keyword">if</span>(schema[field].required) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!values[field]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(validate(schema, &#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(validate(schema, &#123;<span class="attr">first</span>:<span class="string">'Bruce'</span>,<span class="attr">last</span>:<span class="string">'Wayne'</span>&#125;)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="Double-Bitwise-NOT"><a href="#Double-Bitwise-NOT" class="headerlink" title="Double Bitwise NOT"></a>Double Bitwise NOT</h1><p><strong>Longhand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">4.9</span>) === <span class="number">4</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p><strong>Shorthand:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">4.9</span> === <span class="number">4</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>librdkafka源码分析</title>
      <link href="/2017/04/16/librdkafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2017/04/16/librdkafka%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://github.com/edenhill/librdkafka" target="_blank" rel="noopener">librdkafka</a>是Apache Kafka的一个C/C++客户端。里面包含了一个C的客户端和一个封装C的C++客户端。两者总的代码行数超过3万行。算起来也是不小。</p><p>我准备从以下几个方面入手，简单分析下C客户端代码的整体结构与线程模型。</p><ul><li>线程模型</li><li>几种重要的队列（queue）</li><li>主要分析Consumer的执行流</li></ul><p>未涉及的包括：</p><ul><li>Producer的执行流</li><li>数据交互的格式以及打包与解包</li><li>Client group</li></ul><p>大部分代码都是以C编写的，从我阅读后来看，整体的代码编写风格很随意，没有固定的代码风格。这可能也会在阅读过程中增加一点难度，第二是C风格的代码免不了宏，因此在分析的时候需要逐一分析，这样代码的上下文很容易丢失。</p><p>阅读的代码为windows平台。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>有以下几个线程：</p><h2 id="主处理线程"><a href="#主处理线程" class="headerlink" title="主处理线程"></a>主处理线程</h2><p>当调用<code>rd_kafka_new</code>时，会传入创建<code>rd_kafka_t</code>对象的类型，也就是<code>RD_KAFKA_CONSUMER</code>或者<code>RD_KAFKA_PRODUCER</code>。之后会调用<code>rd_kafka_cgrp_new</code>创建<code>rd_kafka_cgrp_t</code>对象，接着就是创建主处理线程，线程的入口为<code>rd_kafka_thread_main</code>。</p><p><code>rd_kafka_thread_main</code>中会从<code>rd_kafka_t</code>对象中的操作队列<code>rk_ops</code>中逐一取出进行操作。操作的数据结构类型为<code>rd_kafka_op_t</code>。操作类型有很多种，参考<code>rd_kafka_op_type_t</code>。操作执行完后调用<code>rd_kafka_op_handle</code>回调。</p><p>这是<code>rd_kafka_thread_main</code>线程的主要工作，其中有一些细节这里未涉及。</p><h2 id="Broker线程"><a href="#Broker线程" class="headerlink" title="Broker线程"></a>Broker线程</h2><p>上述<code>rd_kafka_thread_main</code>线程创建完后，调用<code>rd_kafka_broker_add</code>创建internal broker线程。broker线程的类型有三种，分别是：</p><ul><li><p>RD_KAFKA_CONFIGURED</p><p>根据用户配置，生成的broker线程</p></li><li><p>RD_KAFKA_LEARNED</p><p>内部使用的broker线程，主要针对Client Group使用</p></li><li><p>RD_KAFKA_INTERNAL</p><p>内部使用的broker线程</p></li></ul><p>Broker线程主要执行的是针对Broker的当前内部状态，比如INIT、DOWN、CONNECT、UP等，在这些状态下，执行针对的操作。比如在<code>RD_KAFKA_BROKER_STATE_UP</code>状态下，根据<code>rk_type</code>（类型为<code>rd_kafka_type_t</code>）来执行<code>rd_kafka_broker_producer_serve</code>或者<code>rd_kafka_broker_consumer_serve</code>。</p><p>Broker线程可能会有多个。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列在librdkafka的数据流转中起到了关键性的作用。主要有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_q_t</span> *rktp_ops;</span><br><span class="line"><span class="keyword">rd_kafka_q_t</span> *rktp_fetchq;</span><br><span class="line"><span class="keyword">rd_kafka_q_t</span> *rkcg_q;</span><br><span class="line"><span class="keyword">rd_kafka_q_t</span> *rk_rep;</span><br><span class="line"><span class="keyword">rd_kafka_q_t</span> *rkcg_q;</span><br></pre></td></tr></table></figure></p><p>buf队列有以下几个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rd_kafka_bufq_t</span> rkb_outbufs;</span><br><span class="line"><span class="keyword">rd_kafka_bufq_t</span> rkb_waitresps;</span><br><span class="line"><span class="keyword">rd_kafka_bufq_t</span> rkb_retrybufs;</span><br></pre></td></tr></table></figure></p><p>在创建<code>rd_kafka_cgrp_t</code>对象时，将<code>rkcg_q</code>设置为<code>rk_rep</code>的转发队列（forward queue）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_kafka_q_fwd_set(rk-&gt;rk_rep, rkcg-&gt;rkcg_q);</span><br></pre></td></tr></table></figure></p><p>在线程<code>rd_kafka_broker_thread_main</code>里，调用<code>rd_kafka_toppar_op_fetch_start</code>设置<code>rktp_fetchq</code>的转发queue为<code>rkcg_q</code>。</p><p>在Broker线程中，rd_kafka_fetch_reply_handle会创建一个临时的queue，然后创建一个rko，将rko压入到临时队列的rkq_q对象中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_kafka_q_enq(rkq, rko)</span><br></pre></td></tr></table></figure></p><p>最后将这个临时queue压入到<code>rd_kafka_toppar_s::rktp_fetchq</code>的转发queue中，也就是rkcg_q。</p><p>Broker 线程会调用<code>rd_kafka_broker_consumer_serve</code>，然后到<code>rd_kafka_broker_fetch_toppars</code>构建一个<code>rd_kafka_buf_t *</code>对象，同时将此对象的<code>rkbuf_cb</code>设置为<code>rd_kafka_broker_fetch_reply</code>。然后将buf压入到broker的<code>rkb_outbufs</code>队列中。</p><p>在<code>rd_kafka_send</code>会从<code>rkb_outbufs</code>获取buf发送之后，会将此buf压入到<code>rkb_waitresps</code>队列中。</p><p>收到回应后，会调用<code>rkbuf_cb</code>会被调用<code>rd_kafka_buf_callback</code>的request，就是rkbuf。<code>rkb-&gt;rkb_waitresps</code>的<code>rkbq_bufs</code>中，通过corrid查找相应的<code>rd_kafka_buf_t</code>对象找到后更新状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_kafka_bufq_deq(&amp;rkb-&gt;rkb_waitresps, rkbuf);</span><br></pre></td></tr></table></figure><h1 id="Consumer执行流"><a href="#Consumer执行流" class="headerlink" title="Consumer执行流"></a>Consumer执行流</h1><p>消费者主动去poll消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd_kafka_consume0(rk, rkcg-&gt;rkcg_q, timeout_ms);</span><br></pre></td></tr></table></figure><p><code>rkcg_q</code>就是<code>rk_rep</code>的转发queue。从<code>rkcg_q</code>取出一个<code>rd_kafka_op_t</code>对象，再从<code>rd_kafka_op_t</code>对象中取得消息（<code>rd_kafka_message_t</code>）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个库的代码结构相对来说还是比较复杂的。上面的分析也很粗糙，有很多细节没有说明。但是大方向有了，其他的细节相分析起来，就会游刃有余，而不是毫无头绪。<br>这个库有一点不好的是队列的转发操作，说白了就是互相保存对象地址，然后在其他地方操作，所以不是很直观。在没弄清楚的情况会让人摸不着头脑。<br>一般我自己在阅读源码时，会遵循以下几个步骤：</p><ul><li>有一个可运行的示例</li><li>理解线程模型</li><li>大致阅读相关数据结构</li><li>将示例的执行流串起来</li><li>抓包查看如何通讯</li></ul><p>然后与以往看过的源码进行一个对比。从代码风格，代码格式化，代码的数据结构，API等方面进行比较。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>防火墙、VPN与MTU</title>
      <link href="/2017/04/09/%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%81VPN%E4%B8%8EMTU/"/>
      <url>/2017/04/09/%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%81VPN%E4%B8%8EMTU/</url>
      <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>因为行业原因，之前理解中的软件都是跑在局域网内，数据的传输至少不会遇上网络方面的原因，除去一些硬件等物理因素。这是常规的用法，测试团队也是基于这样的网络环境进行测试，也包括防火墙。</p><p>编程方面有一句名言：</p><blockquote><p>永远不要假设编程。</p></blockquote><p>我所理解的是，除去我们能够想到的（也就是我们假设的）正常case外，应该尽量地考虑其他case，包括边界case和环境因素。恰恰大部分人（有些时候包括我自己）平常所进行的都是假设编程。</p><p>工程团队的一个现场：一个调控中心（称为C），多个采集站（称为S）。C和S是异地，中间有防火墙，数据通过VPN走公网。<br>当时是10个采集站。报告说有几个站数据一直时好时坏。</p><p>远程登录后，用procexp看了下，有几个站在进行疯狂的重连（用的是TCP协议）。一个链路建立没多久就被关闭，然后又新建一个链路。第一反应是感觉很蹊跷，想到的是会不会超时时间过短？在前面一个链路未完全建立的情况下超时了，导致主动断开又重连。</p><p>但是反过来又说不通，因为其他几个站的数据完好，且用的是同样的超时时间。（正因为上述的假设，没考虑到网络延时因素）后来用wireshark抓包看了下，有些情况下是采集站主动关闭链路，有些时候又不是。其中有个规律是，采集站主动关闭的前一刻，有个超大的数据包从C发往S。而这种情况在数据好的采集站中未发现过。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>经过后续的询问与调查，发现C与S数据未通的几个站的网络延时相对来说非常高，基本在150ms以上。可以确定是C这端的数据粘连成一个很大的数据包，这个很大的数据通过防火墙后，被防火墙丢弃了，因为数据包大小超过了MTU值。导致S端认为链路出现了状况，进行了主动关闭。<br>关于走VPN导致数据不稳定的情况，网上有很多帖子。情况基本一致。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>方法就是调整MTU的值。防火墙的设置基本是固定的，1500。所以能想到的是改变主机的MTU。<br>以下是在Windows平台的操作。<br>首先是找到发包相应的网络适配器名称：<br>netsh interface ipv4 show subinterface</p><p>找到名称后，进行修改：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> subinterface “网络A” mtu = <span class="number">1400</span> store=persistent</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于很多现实原因，测试环境无法和真实的生产环境一致，以及大部分时候开发人员的假设编程等情况。综合各种情况，在特定的场景中会一些我们无法预料的到情况。反过来看，从各种意外状况，需要反省，不管是测试用例，测试场景还是开发时的思维模式。因为这些都是正反馈，有反馈才能有目的的改善。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python的ctype与dll的交互2</title>
      <link href="/2017/03/12/python%E7%9A%84ctype%E4%B8%8Edll%E7%9A%84%E4%BA%A4%E4%BA%922/"/>
      <url>/2017/03/12/python%E7%9A%84ctype%E4%B8%8Edll%E7%9A%84%E4%BA%A4%E4%BA%922/</url>
      <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><a href="http://codingeek.me/2017/01/22/python%E7%9A%84ctype%E4%B8%8Edll%E7%9A%84%E4%BA%A4%E4%BA%92/" target="_blank" rel="noopener">上一篇</a>文章说了python与dll交互间的数据结构问题。这篇文章说下dll中的回调问题。介绍python的c回调的文章网上有很多，但很多都是无法工作。因此在此记录下整个过程。</p><h1 id="C的回调"><a href="#C的回调" class="headerlink" title="C的回调"></a>C的回调</h1><p>通常c写的回调都是类似这样的结构：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* a1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_s</span> <span class="title">A_t</span>;</span></span><br><span class="line">TESTDLL_API int function1(void (*outputcallback)(const A_t* a, void* b), void* param);</span><br></pre></td></tr></table></figure><p>在c或者C++中调用的话，第一个参数可以传入一个签名匹配到回调的方法或者lambda对象（Lambda参考<a href="http://codingeek.me/2017/03/04/Callback-in-C-and-C/" target="_blank" rel="noopener">这篇</a>）。</p><h1 id="python的回调"><a href="#python的回调" class="headerlink" title="python的回调"></a>python的回调</h1><p>在python中，需要定义相应的数据结构，接下来就是回调的原型定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">"a1"</span>, c_char_p),</span><br><span class="line">        (<span class="string">"a2"</span>, c_int)]</span><br><span class="line">CMPFUNC = CFUNCTYPE(<span class="keyword">None</span>, POINTER(A), c_void_p)</span><br></pre></td></tr></table></figure><p>CFUNCTYPE的第一个参数是回调的返回值，接下是回调的参数。有一点需要注意的是，任何传入c接口的参数都是ctypes类型，而不是python的内置内类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.dllModule.function1(self.cb, c_int(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>回调中的第一个参数是一个对象，这个对象包含了一个contents字段，在这个字段中才是我们自定义的字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        print(dir(a))</span><br><span class="line">        print(a.contents.a1, a.contents.a2)</span><br><span class="line">        print(b)</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码在<a href="https://github.com/navono/blog_code/tree/master/python-callback" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Callback in C and C++</title>
      <link href="/2017/03/04/Callback%20in%20C%20and%20C++/"/>
      <url>/2017/03/04/Callback%20in%20C%20and%20C++/</url>
      <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>前面一段时间一直在看<a href="https://github.com/KjellKod/g3log" target="_blank" rel="noopener">g3log</a>和<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>的源码。在看完也写了点例子操作后，看到g3log里面只有<a href="https://github.com/navono/g3Log_Sinks" target="_blank" rel="noopener">FileSink</a>，因此想自己写一个SocketSink，这个版本实现只是功能上的实现。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>因为g3log是C++11开发的，但是libuv库又是一个C库，而且是大量使用回调的模式的事件驱动库。因此两者的结合看起来很奇怪。站在使用者角度，当然是使用C++11风格的好。但是在试过以下代码，发现C++11的Lambda好像和C的回调不是那么匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> connect_cb = [](<span class="keyword">uv_connect_t</span>* req, <span class="keyword">int</span> status) &#123;</span><br><span class="line">uv_read_start((<span class="keyword">uv_stream_t</span>*)req-&gt;handle, on_alloc, on_read);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">uv_tcp_connect(&amp;con_req, client, (<span class="keyword">const</span> sockaddr*)&amp;addr, connect_cb);</span><br></pre></td></tr></table></figure><p>在VS2010中编译不通过，原因是因为Lambda在生成Closure的时候使用了上下文，而C的回调刚好和调用的上下文无关的。因此无法将function形式的函数转换成函数指针。但是在VS2015中则可以。</p><p>但是又存在另一个问题，就是如果想要将on_alloc和on_read也使用Lambda就会存在问题，因为在connect_cb内部使用的话：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> alloc_cb = [](<span class="keyword">uv_handle_t</span>* handle, <span class="keyword">size_t</span> suggested_size, <span class="keyword">uv_buf_t</span>* buf) &#123;</span><br><span class="line">    buf-&gt;base = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(suggested_size);</span><br><span class="line">    buf-&gt;len = suggested_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> connect_cb = [](<span class="keyword">uv_connect_t</span>* req, <span class="keyword">int</span> status) &#123;</span><br><span class="line">    uv_read_start((<span class="keyword">uv_stream_t</span>*)req-&gt;handle, alloc_cb, on_read);</span><br><span class="line">&#125;;</span><br><span class="line">uv_tcp_connect(&amp;con_req, client, (<span class="keyword">const</span> sockaddr*)&amp;addr, connect_cb);</span><br></pre></td></tr></table></figure><p>就需要capture为引用或者拷贝，这样就导致了在使用<em>connect_cb</em>会报出类似：</p><blockquote><p>error C3493: ‘alloc_cb’ cannot be implicitly captured because no default capture mode has been specified </p></blockquote><blockquote><p>error C2664: ‘int uv_tcp_connect(uv_connect_t ,uv_tcp_t ,const sockaddr *,uv_connect_cb)’: cannot convert argument 4 from ‘int’ to ‘uv_connect_cb’</p></blockquote><p>这样的错误。但是在connect_cb中使用[&amp;] capture，又会导致</p><blockquote><p>error C2664: ‘int uv_tcp_connect(uv_connect_t ,uv_tcp_t ,const sockaddr *,uv_connect_cb)’: cannot convert argument 4 from ‘run_tcp_client::‘ to ‘uv_connect_cb’</p></blockquote><p>陷入了两难境地。google了一把，就想将一些东西记录在这。</p><h1 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h1><h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>大部分想到的是传统方案，也就是使用接口类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Abstract Base Class</span></span><br><span class="line"><span class="comment">// Those who want to provide a callback must derive from this class and</span></span><br><span class="line"><span class="comment">// provide an implementation of cbiCallbackFunction().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallbackInterface</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The prefix "cbi" is to prevent naming clashes.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">cbiCallbackFunction</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// "Caller" allows a callback to be connected.  It will call that callback.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Clients can connect their callback with this</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectCallback</span><span class="params">(CallbackInterface *cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Test the callback to make sure it works.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Caller::test() calling callback...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = m_cb -&gt; cbiCallbackFunction(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Result (20): %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The callback provided by the client via connectCallback().</span></span><br><span class="line">    CallbackInterface *m_cb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// "Callee" can provide a callback to Caller.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee</span> :</span> <span class="keyword">public</span> CallbackInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The callback function that Caller will call.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cbiCallbackFunction</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  Callee::cbiCallbackFunction() inside callback\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caller caller;</span><br><span class="line">Callee callee;</span><br><span class="line"><span class="comment">// Connect the callback</span></span><br><span class="line">caller.connectCallback(&amp;callee);</span><br><span class="line"><span class="comment">// Test the callback</span></span><br><span class="line">caller.test();</span><br></pre></td></tr></table></figure></p><p><strong>优点：</strong></p><ul><li>如果要处理多个回调，可以直接往接口类里添加</li><li>清晰简单</li></ul><p><strong>缺点：</strong></p><ul><li>接口可能存在名字冲突</li><li>只能继承一次</li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Callback function pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*CallbackFunctionPtr)</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// "Caller" allows a callback to be connected.  It will call that callback.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Clients can connect their callback with this.  They can provide</span></span><br><span class="line">    <span class="comment">// an extra pointer value which will be included when they are called.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectCallback</span><span class="params">(CallbackFunctionPtr cb, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cb = cb;</span><br><span class="line">        m_p = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Test the callback to make sure it works.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Caller::test() calling callback...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = m_cb(m_p, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Result (20): %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The callback provided by the client via connectCallback().</span></span><br><span class="line">    CallbackFunctionPtr m_cb;</span><br><span class="line">    <span class="comment">// The additional pointer they provided (it's "this").</span></span><br><span class="line">    <span class="keyword">void</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// "Callee" can provide a callback to Caller.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// This static function is the real callback function.  It's compatible</span></span><br><span class="line">    <span class="comment">// with the C-style CallbackFunctionPtr.  The extra void* is used to</span></span><br><span class="line">    <span class="comment">// get back into the real object of this class type.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticCallbackFunction</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Get back into the class by treating p as the "this" pointer.</span></span><br><span class="line">        ((Callee *)p) -&gt; callbackFunction(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The callback function that Caller will call via </span></span><br><span class="line">    <span class="comment">// staticCallbackFunction() above.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbackFunction</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  Inside callback\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caller caller;</span><br><span class="line">Callee callee;</span><br><span class="line"><span class="comment">// Connect the callback.  Send the "this" pointer for callee as the </span></span><br><span class="line"><span class="comment">// void* parameter.</span></span><br><span class="line">caller.connectCallback(Callee::staticCallbackFunction, &amp;callee);</span><br><span class="line"><span class="comment">// Test the callback</span></span><br><span class="line">caller.test();</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>和C风格的回调兼容</li></ul><p><strong>缺点：</strong></p><ul><li>实现优点复杂，优点绕</li></ul><h2 id="C-11-Lambda"><a href="#C-11-Lambda" class="headerlink" title="C++11 Lambda"></a>C++11 Lambda</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Callee(<span class="keyword">int</span> i) : m_i(i) &#123; &#125;</span><br><span class="line">    <span class="comment">// The callback function that Caller will call.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbackFunction</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  Callee::callbackFunction() inside callback\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> m_i * i; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// To prove "this" is indeed valid within callbackFunction().</span></span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; CallbackFunction;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Clients can connect their callback with this.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectCallback</span><span class="params">(CallbackFunction cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Test the callback to make sure it works.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Caller::test() calling callback...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = m_cb(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Result (50): %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// The callback provided by the client via connectCallback().</span></span><br><span class="line">    CallbackFunction m_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Caller caller;</span><br><span class="line"><span class="function">Callee <span class="title">callee</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">// Connect the callback.  Like with the C-style function pointer and </span></span><br><span class="line"><span class="comment">// static function, we use a lambda to get back into the object.</span></span><br><span class="line">caller.connectCallback(</span><br><span class="line">    [&amp;callee](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> callee.callbackFunction(i); &#125;);</span><br><span class="line"><span class="comment">// Test the callback</span></span><br><span class="line">caller.test();</span><br></pre></td></tr></table></figure><h2 id="模板函子"><a href="#模板函子" class="headerlink" title="模板函子"></a>模板函子</h2><p>实现<a href="http://www.tutok.sk/fastgl/callback.html" target="_blank" rel="noopener">在这</a>。可以用C++11的可变模板实现。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>最终要解决上述的问题是，要解决capture的问题。解决方案是引入一个“bounce”函数。解决上下文问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span><span class="comment">/*static std::function&lt;void(uv_connect_t* req, int status)&gt;*/</span> connect_bounce</span><br><span class="line">= [&amp;](<span class="keyword">uv_connect_t</span>* req, <span class="keyword">int</span> status) &#123;</span><br><span class="line">uv_read_start((<span class="keyword">uv_stream_t</span>*)req-&gt;handle, alloc_cb, read_cb);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> connect_cb = [](<span class="keyword">uv_connect_t</span>* req, <span class="keyword">int</span> status) &#123;</span><br><span class="line">    connect_bounce(req, status);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，alloc_cb和read_cb就可以使用正常的lambda了。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="http://tedfelix.com/software/c++-callbacks.html" target="_blank" rel="noopener">http://tedfelix.com/software/c++-callbacks.html</a></li><li><a href="http://www.alecjacobson.com/weblog/?p=3779" target="_blank" rel="noopener">http://www.alecjacobson.com/weblog/?p=3779</a></li><li><a href="https://www.cabbages-and-kings.net/2014/08/11/c_style_callbacks_with_c_functions.html" target="_blank" rel="noopener">https://www.cabbages-and-kings.net/2014/08/11/c_style_callbacks_with_c_functions.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>g3log源码分析</title>
      <link href="/2017/02/17/g3log%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2017/02/17/g3log%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>源代码地址：<a href="https://github.com/KjellKod/g3log" target="_blank" rel="noopener">github</a></p><h1 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h1><p><img src="g3log_loc.PNG" alt="统计"></p><p>从代码量上看，代码不是很多，所以整个库的结构也不会太复杂。首先从整体上有个概念，就需要看下整个库的类结构如何，以及类间的关系如何。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="头文件结构"><a href="#头文件结构" class="headerlink" title="头文件结构"></a>头文件结构</h2><p>通过VS2015的头文件依赖图，从整体的头文件依赖结构上看下整个工程是如何依赖的。</p><p><img src="hppDepends.PNG" alt="依赖"></p><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><p>首先是LogWorker，这是库的核心类，包含了创建LogWorker实例的静态方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LogWorker&gt; createLogWorker();</span><br></pre></td></tr></table></figure><p>以及构建本地log日志文件信息和Sink的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FileSinkHandle&gt; addDefaultLogger(</span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; log_prefix, </span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; log_directory, </span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; default_id = <span class="string">"g3log"</span>);</span><br><span class="line">           </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> DefaultLogCall&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;g3::SinkHandle&lt;T&gt;&gt; addSink(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; real_sink, DefaultLogCall call);</span><br></pre></td></tr></table></figure><p>最后就是保存日志的两个方法，一个是正常的保存，一个是异常的保存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(LogMessagePtr entry)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatal</span><span class="params">(FatalMessagePtr fatal_message)</span></span>;</span><br></pre></td></tr></table></figure><p>内部还有一个私有的实现impl：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogWorkerImpl _impl;</span><br></pre></td></tr></table></figure><p>LogWorkerImpl内部保存了Sink的的列表，以及一个C++11线程的Active对象。也是这个log库号称异步的原因。<br>线程的Active实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>() &gt; Callback;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Active</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      Active() : done_(<span class="literal">false</span>) &#123;&#125; <span class="comment">// Construction ONLY through factory createActive();</span></span><br><span class="line">      Active(<span class="keyword">const</span> Active &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      Active &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Active &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">            Callback func;</span><br><span class="line">            mq_.wait_and_pop(func);</span><br><span class="line">            func();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      shared_queue&lt;Callback&gt; mq_;</span><br><span class="line">      <span class="built_in">std</span>::thread thd_;</span><br><span class="line">      <span class="keyword">bool</span> done_;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">virtual</span> ~Active() &#123;</span><br><span class="line">         send([<span class="keyword">this</span>] &#123; done_ = <span class="literal">true</span>;&#125;);</span><br><span class="line">         thd_.join();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Callback msg_)</span> </span>&#123;</span><br><span class="line">         mq_.push(msg_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/// Factory: safe construction of object before thread start</span></span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Active&gt; createActive() &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Active&gt; aPtr(<span class="keyword">new</span> Active());</span><br><span class="line">         aPtr-&gt;thd_ = <span class="built_in">std</span>::thread(&amp;Active::run, aPtr.get());</span><br><span class="line">         <span class="keyword">return</span> aPtr;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>整体的思路就是维护一个消息queue，然后在run中不停地从queue中取对象执行。当queue中没有消息时，run会等待在mq_.wait_and_pop(func)这里。</p><p>LogWorker的save和fatal是将消息转发给LogWorkerImpl的后台线程去执行，具体执行的是LogWorkerImpl的bgSave和bgFatal。而这两个方法最后都会传递给Sink<t>的实例的send去执行。接下来就是Sink的具体实现。源码中只实现了FileSink，也就是将日志消息保存到本地文件中。这个类的内部的fileWrite方法也是Thread Active最终要执行的执行体。</t></p><p>这里有个需要注意的地方。就是内部使用的Sink都是被封装成模板类Sink<t>（继承SinkWrapper接口）的实例，Sink<t>本身有两个方法：</t></t></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void send(LogMessageMover msg) override；</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Call, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">auto async(Call call, Args &amp;&amp;... args)-&gt; std::future&lt; typename std::result_of&lt;decltype(call)(T, Args...)&gt;::type&gt;();</span><br></pre></td></tr></table></figure><p>以及一个函数对象_default_log_call：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(LogMessageMover) &gt; AsyncMessageCall;</span><br><span class="line">AsyncMessageCall _default_log_call;</span><br></pre></td></tr></table></figure></p><p>保存的是最初传入的FileSink::fileWrite。</p><p>第一个方法是对SinkWrapper接口API的实现。而第二个方法则是返回给用户用于异步调用的。也就是SinkHandle<t>，其中的T就是Sink<t>。最后Sink<filesink>保存在LogWorkerImpl的std::vector _sinks中。</filesink></t></t></p><p>最后一个就是LOG宏中用到的LogCapture。此类中包含了一条log日志的所有信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::ostringstream _stream;</span><br><span class="line">std::string _stack_trace;</span><br><span class="line"><span class="keyword">const</span> char *_file;</span><br><span class="line"><span class="keyword">const</span> int _line;</span><br><span class="line"><span class="keyword">const</span> char *_function;</span><br><span class="line"><span class="keyword">const</span> LEVELS &amp;_level;</span><br><span class="line"><span class="keyword">const</span> char *_expression;</span><br><span class="line"><span class="keyword">const</span> g3::SignalType _fatal_signal;</span><br></pre></td></tr></table></figure><p>在析构时，调用全局的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveMessage(_stream.str().c_str(), _file, _line, _function, _level, _expression, _fatal_signal, _stack_trace.c_str());</span><br></pre></td></tr></table></figure><p>进行日志保存。</p><h2 id="全局方法"><a href="#全局方法" class="headerlink" title="全局方法"></a>全局方法</h2><p>包含以下几个全局设置的方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeLogging</span><span class="params">(LogWorker *logger)</span></span>;</span><br><span class="line">void setFatalPreLoggingHook(std::function&lt;void(void)&gt;  pre_fatal_hook);</span><br><span class="line">void setFatalExitHandler(std::function&lt;void(FatalMessagePtr)&gt; fatal_call);</span><br></pre></td></tr></table></figure><p>还有在namespace internal的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *entry, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *function, <span class="keyword">const</span> LEVELS &amp;level, <span class="keyword">const</span> <span class="keyword">char</span> *boolean_expression, <span class="keyword">int</span> fatal_signal, <span class="keyword">const</span> <span class="keyword">char</span> *stack_trace)</span></span></span><br></pre></td></tr></table></figure><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"> subgraph main</span><br><span class="line">        createLogWorker--&gt;addDefaultLogger</span><br><span class="line">        addDefaultLogger--&gt;initializeLogging</span><br><span class="line">        end</span><br><span class="line">        subgraph LogWorkerImpl</span><br><span class="line">        bgSave--&gt;sink<span class="string">'save</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        subgraph sink</span></span><br><span class="line"><span class="string">        sink_bg--&gt;_default_log_call</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        LOG--&gt;saveMessage</span></span><br><span class="line"><span class="string">        saveMessage--&gt;LogWork_save</span></span><br><span class="line"><span class="string">        LogWork_save-- async --&gt;bgSave</span></span><br><span class="line"><span class="string">        sink'</span>save-- <span class="keyword">async</span> --&gt;sink_bg</span><br></pre></td></tr></table></figure><p>不支持。。。Fu*k。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZeroMQ理论基础</title>
      <link href="/2017/02/12/ZeroMQ%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/02/12/ZeroMQ%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>不像其他（中心式）基于容易理解的理论基础的消息传输系统。 几乎没有关于通用式分布式消息传输系统的资源，尤其是读者特别感兴趣的ØMQ。</p><p>这篇论文的目的是解释ØMQ架构的基本元素，他们是如何相互协调以及他们这样设计的理由。</p><h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p>拓扑结构是ØMQ的主要概念。除非你真正理解“拓扑结构”是什么意思，否则其中出现的一些概念导致混淆以及难于理解，甚至导致设计不当。</p><p>作为一个非正式的定义，我们可以把“拓扑结构”理解成参与到业务逻辑的相同的方面的一组应用程序。</p><p>例如：考虑一个图片转换服务，将图片调整到所需的大小和分辨率。所有的应用程序都提供了转换服务，所有的应用程序都使用服务。所有的中间节点，比如负载均衡，形成了一个拓扑结构。</p><p>从技术层面来说，拓扑结构有以下属性：</p><ul><li>拓扑是个图，图中的节点是应用程序，格子（lattices）是应用程序之间的数据通道。</li><li>所有的应用程序在业务逻辑方面都有一致的路线协议。</li><li>这个图是紧密连接的。也就是：任意两个节点要不是直接连通，要不就是通过其他中间节点间接连通。</li></ul><p>第一点很明显。有一点需要指出的是，“通道（channel）”一词是故意使用，用来替代“连接（connection）”，来描述这个模型，甚至底层是无连接的传输，比如IP多播或UDP。</p><p>第二点说的是，在拓扑结构中，所有的应用程序都有一致消息传输（比如“图片需要调整大小”或“这是一张调整过大小的图片”），一致的消息序列（在应用程序中以状态机实现），实际的数据编码（图片数如何序列化的？RGB？CMYK？）等等。</p><p>第三点说的是，即使是有两个相同业务逻辑的部署，他们形成的也是两个拓扑结构，除非他们通过数据通道进行相互连接。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts1.png" alt="topology1"></p><p>为了直观理解拓扑结构概念，重要的是理解fuzzy概念。同样fuzzy的是面向对象编程中的类。存在一个正式的定义解释类是数据成员和方法的集合。但是没有定义解释哪一部分的业务逻辑应该形成一个类，哪一部分不应该。完全依赖于程序员去决定哪个业务概念需要封装成类，哪个不需要。程序员可能会犯错，将所有的业务逻辑放到一个类中，因此几乎回避了面向对象设计；或者将逻辑分布到千万个小的类中，这就将程序员置于难以理解的相互关联的混乱之中。</p><p>同样地，没有一个单一的正确方式将业务逻辑划分到拓扑结构中。唯一的经验法则是，拓扑是扩展的原子单元。你可以将拓扑结构作为整体进行扩展，而不能只是扩展其某一方面。因此，如果你期待在将来需要将功能A与功能B相互独立，你应该直接为A单独创建一个拓扑结构，为B单独创建一个拓扑结构。</p><p>我们拿一个例子来阐述说明上述的概念：<br>在我们的图片转换程序中，有两个基本功能：调整图片大小和调整图片的亮度。我们可以选择将这两个功能创建一个拓扑，或者为每个功能创建“大小调整”拓扑和“亮度调整”拓扑。</p><p>前面这种场合，我们需要定义某种路线传输方式来传达我们想要的功能。比如说，消息的第一个字节为1代表“大小调整”,2代表“亮度调整”。同时我们应该注意的是，这种设计导致这两个功能是紧密耦合的。如果在将来我们打算增加更多的处理节点，他们的每一个都应该实现这两个功能。</p><p>后面这种场合，这两个功能是不相交的。在消息中，没有必要设置特殊的字段来代表选择的功能，在“大小调整”拓扑中，所有的请求都是请求调整图片大小，在“亮度调整”拓扑中，所有的请求都是请求调整图片亮度。在这个设计中，我们可以独立扩展每个拓扑结构而不影响其他的拓扑。假设我们想设计一个专用的FPGA来调整图片大小，我们可以简单地将它们连接到“大小调整”拓扑结构，而不影响“亮度调整”拓扑。如下图。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts2.png" alt="topology2"></p><p>客户端可以请求调整大小（通过拓扑A）和调整亮度（通过拓扑B），worker1只能调整图片大小，worker3只能调整图片亮度，而worker2可以提供调整图片大小和调整图片亮度两个功能。</p><p>最后关于拓扑结构要注意的是，由于很清晰地在拓扑结构之间进行了划分，就可以映射到底层的传输协议的某一方面，比如TCP端口。这就允许底层的网络按照业务规范其行为。比如，测量特定拓扑结构的带宽消耗（和特定的业务逻辑，比如调整图片大小服务的带宽消耗与调整图片亮度服务的带宽消耗）。可以基于拓扑结构进行流量调整。比如减少调整图片大小服务的带宽，用来增加调整图片亮度服务的带宽等等。</p><h1 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h1><p>经常会出现在不同的传输机制的上层，除了TCP之外，会要求运行一层消息层，比如InfiniBand（处于性能考虑），IP多播或者SCTP。<br>原生的方法是开启一个TCP传输，然后在此之上增加一些TCP缺少的特性，比如心跳。在其他的底层传输之上提供一个相同的行为。<br>这个方法有几个问题：</p><ul><li>首先，在特定的协议之上，构造一个类TCP的包装器会变得很冗余。如果它的行为类似TCP，那为何不一开始就用TCP。（这条规则排除因为性能的原因）</li><li>其次，一些协议不能硬塞进TCP模型中。例如：IP广播。</li></ul><p>基于上述特定的问题，ØMQ采用了不同的方案。底层的传输保持了各自的原生特性而不用提供一个共通的东西，在上层进行了一层封装。不同的是，ØMQ提供了一组最小的接口（消息界定，消息分割和消息原子性），同时要求上层足够的通用来处理底层各个不同的传输模式。<br>实际中，它意味着在传输层之上有一层很”薄”的封装。例如消息界定协议（当封装TCP的时候）、消息分割协议（将长的消息分割成多个基于包传输的数据包）或late-joiner协议（当加入PGM多播流的时候，丢弃接收到消息的最后一部分）</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts5.png" alt="topology3"></p><h1 id="拓扑结构的建立-VS-消息路由"><a href="#拓扑结构的建立-VS-消息路由" class="headerlink" title="拓扑结构的建立 VS. 消息路由"></a>拓扑结构的建立 VS. 消息路由</h1><p>网络栈的每一层都将网络传输中的一部分复杂进行了抽象。IP层抽象掉了需要查找到路由的目标主机。TCP抽象掉了网络内在的丢包属性，提供了 可靠性保证。<br>ØMQ抽象掉了将要发送数据的需要指定的特定网络位置。消息被发送到拓扑结构中，而不是特定的一个端点。回忆一下，拓扑结构是和特定业务逻辑绑定的，这也就意味着，你从一个拓扑结构发送消息，你是要求这个拓扑结构给你提供特定的服务，比如是图片调整大小或者明亮度调整。ØMQ会以用户透明的方式选择一个真正的端点来接收消息。</p><p>为了落实这一原则，ØMQ严格区分了拓扑结构的建立（zmq_bind,zmq_connect）和实际消息的传输（zmq_send,zmq_recv）。<br>前者处理底层的传输地址，比如IP地址，后者使用一个句柄（fd）去访问特定的拓扑结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Topology establishment */</span></span><br><span class="line"><span class="keyword">int</span> s = zmq_socket (...);</span><br><span class="line">zmq_connect (s, <span class="string">"tcp://192.168.0.111:5555"</span>);</span><br><span class="line"><span class="comment">/* Message routing */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> data [] = <span class="string">"ABC"</span>;</span><br><span class="line">zmq_send (s, data, <span class="keyword">sizeof</span> (data), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将拓扑结构的建立和消息的路由分开严格上说不是不可或缺的。毕竟，结合两个单一的函数很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zmq_send (s, <span class="string">"tcp://192.168.0.111:5555"</span>, data, <span class="keyword">sizeof</span> (data), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>区分开既有技术上的又有教育意义上的理由。技术上的理由是：</p><ul><li>当我们想以异步的方式从拓扑结构中接收消息时，无论如何我们必须连接到它。没有理由不继续利用这个通道进行消息的发送。</li><li>将拓扑结构的建立和消息路由分开可以很好地映射到BSD的socket API（bind/connect VS. send/recv）</li></ul><p>教育意义上的观点甚至更重要。它涉及到ØMQ是什么以及它不是什么。<br>底层的协议，例如TCP，允许用户向特定的端点发送数据。ØMQ是构建在此基础之上，允许用户向特定的拓扑结构发送数据而不是特定的端点。因此，如果你想要向特定的端点发送数据，你应该使用TCP或者类似的协议。如果你想要将数据发送到拓扑结构，让拓扑结构来决定数据的最终端点，你应该使用ØMQ。</p><p>不幸的是，这个概念似乎很难去理解。其实，几乎不可能去说服用户ØMQ不能用于处理特定的端点，这个不是个bug而是个特性。<br>将拓扑结构的建立和消息的路由分开没有解决这个问题，只是将实际的功能变得更显而易见。在这个特性中增加名称解析，希望能让事实变得更清晰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zmq_connect (s, <span class="string">"Brightness-Adjustment-Service"</span>);</span><br><span class="line">zmq_send (s, data, <span class="keyword">sizeof</span> (data), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="消息传输模式"><a href="#消息传输模式" class="headerlink" title="消息传输模式"></a>消息传输模式</h1><p>当谈及到拓扑结构作为消息路由的一种手段时，在不同的拓扑结构中的路由算法的区别就变得很清晰。“NASDAQ股票报价”拓扑结构将报价分布到拓扑中的每个消费者，“图片明亮度调整”拓扑结构将从客户端接收到的图片交给一个worker去转换，然后将调整过的图片发回给客户端。<br>ØMQ通过定义几种不同的“消息传输模式”来反应这个事实。前面这个股票报价拓扑结构，就是发布/订阅模式的一个例子。后面这个图片明亮度调节拓扑结构就是一个请求/回复模式的一个例子。</p><p>消息传输模式既定义了用于节点间的通信协议，又定义了各个独立节点的功能。e.g.用于路由消息的算法。因此，不同的模式行为看上去像不同的协议。你不能将发布/订阅节点和请求/回复节点进行连接，就好像将TCP端点不能连接到SCTP端点一样。每一个拓扑结构都只实现了一个单一的消息传输模式。不存在一种方法将两个不同的消息传输模式的拓扑结构连接成一个拓扑结构。<br>这个严格的区分对于拓扑结构作为一个整体来保证其行为是有必要的。只要你知道在拓扑结构中的每个端点都坚持提供发布/订阅语义，你就可以提供类似“消息会被投递在拓扑结构中的每个端点”的保证。如果拓扑结构的某一部分允许负载均衡而不是广播，你就不能做出上述那样的保证。更糟的是，消息传输模式是开放式的，你可能需要以一种完全任意的方式去扩展一个端点的行为，因此你没办法做出任何保证。<br>下面是网络栈的示意图。需要注意的是，不同的消息传输模式都位于栈的同一层且相互间是独立的。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts6.png" alt="topology4"></p><p>考虑到一些传统的消息传输系统选择提供通用的路由基础设施允许用户在此之上基本可以构建任意的路由算法（例如AMQP），而不是提供预包装的消息传递模式。所以有必要解释一下ØMQ选择后者的理由。</p><ul><li>第一，设计一个功能齐全又没有bug的消息传输模式是很困难的任务。通过将创建模式的责任转交给用户，我们可以保证基于此消息传输系统构建的大部分应用在某些方面是有问题的。即使是这个模式实现是正确的，学习和开发的开销的成本将会超过使用预包装的消息传递模式的成本的数倍。毕竟，在DNS设计方面的一篇早期论文中提及：“[用户]想要的是使用这个系统所提供的功能，而不是理解。”</li><li>第二，正式定义的模式允许执行一些需求，比如两个不同的模式不能在同一个拓扑结构中存在。消息传输系统可以检查对方是否也实现了相同的消息传输模式，如果不是则直接拒绝连接。如果由用户实现此类的模式，类似这样的检查很可能就不会存在。</li><li>第三，通用的路由基础设施不能自动地支持分布式（别名：federated），这意味着只在简单的中心辐射型（hub-and-spoke）架构下才能工作，一旦想要超出这个模型，就必须要提供额外的信息。也就是回答类似“这个系统的消息传输模型是什么？”的问题。看一下基于AMQP的各类产品实现的“集群”机制。“模式”的特性依旧还存在，或者显示或者隐示（通过只支持一种模式）。</li><li>最后，基于我们在AMQP的经验，尽管它提供了大量丰富的可能的消息传输模式，人们一次又一次的基于它实现相同的几个模式，而忽略了其他东西。</li></ul><h1 id="Hop-by-Hop-VS-End-to-End"><a href="#Hop-by-Hop-VS-End-to-End" class="headerlink" title="Hop-by-Hop VS. End-to-End"></a>Hop-by-Hop VS. End-to-End</h1><p>在网络栈中最巧妙的一个特性就是就是清晰的hopby-hop功能（IP）和end-to-end功能（TCP，UDP，SCTP等），也就是这个特性，将整个网络栈生态切分开，独立发展。如果没有这种功能的切分，end-to-end协议的每一个小改动对于IPv4和IPv6传输来说都是一种痛苦。<br>这个想法的背后就是在网络传输过程中的每个节点都实现IP协议，然而，只有终端才会实现特殊的end-to-end协议，比如TCP。换句话说，中间节点，比如路由器，不需要知道在IP层之上的end-to-end协议。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts8.png" alt="topology5"></p><p>将IP和TCP层切分的经验之后推广，形成了end-to-end argument形式。end-toend argument说的是，如果它的功能不能够被底层正确地提供（在我们的情况中就是hop-by-hop），也就是，它想要正常工作需要上层（end-to-end层）的协助，那么起初在底层实现也就没多大意义了。</p><p>ØMQ坚持end-to-end协议，将栈切分到hop-by-hop层（将节点用”X”开头表示）和end-to-end层（没有用”X”开头表示），这个和上述TCP/IP的拓扑图很像。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts9.png" alt="topology6"></p><p>和TCP/IP同样的是，hop-by-hop层负责消息路由，end-to-end层可以提供附加的服务，比如可靠性，加密等。</p><p>然后我们不应该将TCP/IP的比喻用在此太过了，不像网络栈中的单hop-by-hop协议（IP）和多end-to-end（TCP，UDP，SCTP等），在ØMQ的每个end-to-end协议中都有它自己的hop-by-hop协议支撑。看起来像这样。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts7.png" alt="topology7"></p><p>这样安排是因为每个消息模式的的路由功能（hop-by-hop提供）都是不一样的，不能再消息模式间共享。如果在未来碰到两个消息模式可以共享一个路由算法，而只在end-to-end的协议不同，那么我们也将会在单个hop-by-hop层之上，混合多个end-to-end协议。</p><p>最终，让我们来看下hop-by-hop VS. end-to-end的具体例子。<br>REQ/REP模式指的是，客户端向多个worker服务端发送一个request请求，worker中的一个会处理这个请求然后产生一个reply，然后将reply发送给客户端。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts13.png" alt="topology8"></p><p>hop-by-hop层要做的是将每个request请求发送到上游节点中的某一个（load-balancing），之后将reply发送给下游的接收到request的节点。</p><p>一切运行良好，直到worker处理request失败，或者因为网络的原因，整个拓扑结构的一部分脱离了整体。在这种情况下，客户端将会被阻塞，等待一个永远都不可能的reply。</p><p>为了解决这个问题，客户端需要设置一个超时，如果没有在超时时间内没有收到reply，就重发这个request。客户端也应该有能力过滤掉重复的reply。</p><p>现在回忆下end-to-end argument，重发功能没有端点的支持是不可能完成的，因此这个不太可能在hop-by-hop层进行实现。</p><p>最终我们得到的是，路由功能在hop-by-hop层实现，在此之上的end-to-end层实现可靠性。</p><h1 id="命名解析"><a href="#命名解析" class="headerlink" title="命名解析"></a>命名解析</h1><p>在写这篇文章的时间点，ØMQ不提供命名服务。为了加入到拓扑结构中，需要指定一个地址，比如IP地址和TCP端口。</p><p>在未来，我们可能会提供命名服务，将一个提供到拓扑结构的名字转换到底层的传输地址。比如，”Brightness-Adjustment-Service”可能被解析成”tcp://192.168.0.1111:5555”。</p><p>这里面需要注意的一个是命名解析服务的选择。比如当连接到”NASDAQ stock quotes”拓扑结构，用户想的是连接到本地的一个股票报价中心而不是NASDAQ自己，或者更糟的是，到竞争对手的股票报价中心。</p><p><img src="http://250bpm.wdfiles.com/local--files/concepts/concepts3.png" alt="topology9"></p><p>通常情况下，命名解析服务都是通过DNS来实现。DNS是唯一个全球可用的分布式数据库。</p><h1 id="附录：设计模式"><a href="#附录：设计模式" class="headerlink" title="附录：设计模式"></a>附录：设计模式</h1><p>[请参考原文]</p><h2 id="一致性原则"><a href="#一致性原则" class="headerlink" title="一致性原则"></a>一致性原则</h2><h2 id="扩展性原则"><a href="#扩展性原则" class="headerlink" title="扩展性原则"></a>扩展性原则</h2><h2 id="新增插入原则"><a href="#新增插入原则" class="headerlink" title="新增插入原则"></a>新增插入原则</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章反应的架构是当前ØMQ的设计，在未来可能会存在变数。希望通过这篇文章能够介绍一些分布的消息传输，并且在这个领域的未来可以形成一些基础方面的共识。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>过年</title>
      <link href="/2017/02/09/%E8%BF%87%E5%B9%B4/"/>
      <url>/2017/02/09/%E8%BF%87%E5%B9%B4/</url>
      <content type="html"><![CDATA[<h1 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h1><p>小的时候，总是很期待过年。因为过年有新衣服，新鞋子穿，还可以见到爸爸妈妈。当然也有烦心的事情，就是寒假作业有很多。但终究还是期待来的多点。除了穿的、吃的，就是大家都聚集在爷爷奶奶家，吃饭，聊天，玩。能够感受到浓厚的家庭气氛。也自然觉得以后的每年都可以这样。</p><p>后来奶奶去世了，整个就变了，大家都不再齐聚在老房子里。不再有聊天，不再有大家坐在一起玩游戏，打扑克牌。之后爷爷也去世了。这个以爷爷奶奶为中心的家也就消失了。</p><p>听到越来越多的人说年还是那个年，但是味早已不是那个味。我也有同感，也一直在想我们为什么会有这种感觉。人的眼界在变，时代在变。只不过是之前的感觉，让那么多的变化给冲淡了。</p><h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>现在也长大了，也不会再去期待年味如同小时候那一般。期待的是能和家人团聚在一起，谈谈一年来的事情，身边的变化。每当听闻村里的哪个哪个老人去世了，总会沉默一阵子，各种思绪都涌上心头。死亡无法逃避，只是太残忍。</p><p>时间没有终点，日复一日。年，只是一个让人体会自己变老，回忆逝去的人的契机。珍惜眼下。</p><h1 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h1><p>将来也会成家，有小孩，希望自己的小孩能对过年有好的期待。能做一个好的自己。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源软件架构</title>
      <link href="/2017/02/07/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
      <url>/2017/02/07/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>The Architecture of Open Source Applications: <a href="http://aosabook.org/en/index.html" target="_blank" rel="noopener">英文地址</a><br><a href="http://www.ituring.com.cn/book/1143" target="_blank" rel="noopener">中文翻译地址</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python的ctype与dll的交互注意点</title>
      <link href="/2017/01/22/python%E7%9A%84ctype%E4%B8%8Edll%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2017/01/22/python%E7%9A%84ctype%E4%B8%8Edll%E7%9A%84%E4%BA%A4%E4%BA%92%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这篇文章不会告诉读者如何去使用ctypes，如何使用ctypes在网上已经有很多重复、简单的例子。这篇文章只是记录自己在实际开发中，使用python测试一个dll模块中遇到的各种问题以及解决办法。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>网络上已经有很多关于ctypes如何与dll交互的文章，大多数也都是点到为止。比如基本类型的使用，指针与引用的处理。但是在实际编程过程中，这里面还有很多细节点需要注意。</p><ul><li><p>版本匹配</p><p>这里要求的是安装的python版本位数与交互的dll的编译版本位数要一致。否则在python加载dll时会提示加载失败。</p></li><li><p>数据类型</p><p>很多博客中已经提及了日常所用的一些C的数据类型，比如c_int,c_long。但是如果用C++开发，且同时用了windows类型，COM类型，那么很明显，基本类型是不够的，自己写class又繁琐。例如VARIANT，FILETIME。这些都是已知的类型。那么就需要导入相应的包。windows类型需要相应的wintypes；COM类型可以借助comtypes包。</p></li><li><p>运行环境</p><p>我自己在开发中使用的python3.X，3.X默认的是使用Unicode。如果dll内部接收的是ASCII的字符串，那么就需要先进行转换，再调用API。可以使用create_string_buffer()进行转换。<br>如果python加载的dll同时还依赖其他的dll，如果不做任何处理，python加载dll时会提示加载失败。原因是python会从python.exe的目录查找被依赖的dll，结果当然就是找不到，所以失败。解决办法有两个：</p><ul><li>第一个是将被依赖的dll的目录加入到环境变量中；</li><li>第二个是将被依赖的所有dll拷贝到python.exe目录。</li></ul><p>在dll代码中，可能存在参数为const char<em>类型，调用方传入nullptr或者NULL的情况。此时python运行期会提示错误。原因没有调查，不得而知。变通方案就是将传入的nullptr改成””。<br>如果dll的导出API接收const char</em>类型，而python又需要传入一个空字符串。如果直接使用””，在dll代码中使用param == ‘\0’将会失败。具体原因未知，但是通过调试，dll端接收到的却是是长度为0的字符串。变通方案就是在dll端用再用长度判断一下。</p><p>在dll端，我们很大概率会使用结构体存储一个结构。比如下面这种格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inner</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> *b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Outter</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">Inner* pInner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一个API接收一个Outter数组指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> declspec(_dllexport) <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Outter *param, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此时在python端，我们需要定义相应的数据结构，如果在C的代码中使用了指针，那么对应在python端也需要使用POINTER：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Inner(Structure):</span><br><span class="line">_fields_ = [(<span class="string">"a"</span>, c_int),</span><br><span class="line">        (<span class="string">"b"</span>,c_char_p)]</span><br><span class="line">class Outter(Structure):</span><br><span class="line">_fields_ = [(<span class="string">"count"</span>, c_uint),</span><br><span class="line">       (<span class="string">"pInner"</span>, POINTER(Inner))]</span><br></pre></td></tr></table></figure><p>这样，在调用的时候，Outter的实例外层加上byref即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">2</span></span><br><span class="line">outter_type = Ouuter * count</span><br><span class="line">outter = outter_type()</span><br><span class="line">dll.func(byref(outter), c_uint(count))</span><br></pre></td></tr></table></figure></p><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p>发现在测试接口中，有些数据集和时间相关。直接从接口中返回的数据倒是有了，但是很难高效地验证数据的有效性。此时借助matplotlib，将数据集通过图表的形式展示出来，就大大提高了验证数据有效性的效率，同时也很方便观察。</p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/01/01/hello-world/"/>
      <url>/2017/01/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
