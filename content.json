{"meta":{"title":"Pingeek","subtitle":"Living,then coding.","description":"凡所有相，皆是虚妄。","author":"Pingeek","url":"http://codingeek.me"},"pages":[{"title":"标签","date":"2017-01-21T11:28:18.000Z","updated":"2017-02-12T00:33:07.968Z","comments":false,"path":"tags/index.html","permalink":"http://codingeek.me/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-01-21T11:28:01.000Z","updated":"2017-02-12T00:42:59.572Z","comments":true,"path":"about/index.html","permalink":"http://codingeek.me/about/index.html","excerpt":"","text":"程序员。热爱编程，热爱代码。目前就职于浙江中控技术股份有限公司研发中心。从事SCADA软件开发。 #技能 语言：C++/C,Python,C# 系统：Windows(10),Linux(Ubuntu 16.10) 环境：Visual Studio,Vim,CLion 工具：Bash,Git #联系方式 邮箱：navono007@gmail.com"},{"title":"分类","date":"2017-01-21T11:14:29.000Z","updated":"2017-02-12T00:33:07.965Z","comments":false,"path":"categories/index.html","permalink":"http://codingeek.me/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript入门需要了解的概念","slug":"JavaScript入门需要了解的概念","date":"2017-07-08T13:40:44.000Z","updated":"2017-07-09T02:24:20.743Z","comments":true,"path":"2017/07/08/JavaScript入门需要了解的概念/","link":"","permalink":"http://codingeek.me/2017/07/08/JavaScript入门需要了解的概念/","excerpt":"","text":"引言 JavaScript的版本 历史 运行时环境 模块化 Babel Webpack 引言&ensp;&ensp;&ensp;作为一个一直从事C\\C++的程序员来说，进入JavaScript的世界就好像从室内泳池一下子到太平洋的感觉。在C++的世界，一切都比较封闭，你只需要一个文本编辑器，一个编译器或者一个IDE就足够了。然后你就能用你最爱的泳姿“游泳”了。而在JavaScript的世界里，除了前者的文本编辑器，要考虑和了解事情实在是太多了。诸如ES5、ES6、Babel、webpack等，每年都会出现各种框架，各种库，层出不穷，完全可以把人淹没。 写这篇文章的目的主要是为了记录在自己进入这个圈子里，在这个过程中学习到的一些知识，了解了这些基础知识，可能就会少走一些弯路。 JavaScript的版本&ensp;&ensp;&ensp;不管何种语言，在进入21世纪后，标准化的工作都进行得越来越频繁。举个例子，拿C++来说，C++98，然后是C++03，之后就是C++11、C++14、C++17、C++20。而且标准委员会对于标准化的进程也做出了比较明确的规划。但是标准的制定和现实中各大编译器厂商的实现之间会有一定的鸿沟。 &ensp;&ensp;&ensp;JavaScript也一样，TC39现在采取的是小步快走的模式，也就是在每一次的标准更新中都只加入少量的特性，但是保持一定的更新频率，而不是一次加入大量的特性，然后好几年更新一次标准。 &ensp;&ensp;&ensp;JavaScript是业界对这门语言的称呼，而在标准制定过程中，是由ECMA这个机构来负责,确切说是ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。所以目前的主流是ES6，或者称为ES2015。 历史 1998年6月，ECMAScript 2.0版发布。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。 2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。 2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。 2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。 2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。 &ensp;&ensp;&ensp;以上信息来自于来自百度百科 &ensp;&ensp;&ensp;上面也提及到，标准的制定和标准的实现是两大阵营。JavaScript的标准实现主要是各大浏览器厂商。而浏览器厂商的实现步伐肯定是落后于标准的制定。但是同时开发者又倾向于在源码中使用新的标准特性，但是用新特性编写的代码在脚本运行环境中又不支持，此时就要谈及到Babel了，一个源码到源码（source-to-source）的转译（transpiller）工具了。 运行时环境&ensp;&ensp;&ensp;目前JavaScript的语言定位是通用型语言，也就是说它不仅仅只是运行在浏览器端，它可以运行在服务端（通过Node.js），运行在移动端（通过React Native），同时也可以创建桌面型应用（通过Electron）。在每个不同的平台上，侧重点是不一样的，所以就导致了应用的一些技术也不同，很明显的就是在服务端和浏览器端的模块化管理。 模块化&ensp;&ensp;&ensp;模块化是每个语言要应用在中大型项目中避免不了的问题。而JavaScript的标准中却迟迟没有对这方面进行标准化。这也就导致了民间出现了很多用于模块化管理的方法或者工具。最常见的也是最主流的有AMD（Asynchronous Module Definition）、CommonJS、UMD（Universal Module Definition）。 &ensp;&ensp;&ensp;三者间的主要区别是： AMD，如其名，是异步加载的，主要用在浏览器端 CommonJs，则是同步加载的，主要用于服务端，Node环境下 UMD的目标则是想统一上述两者的语法差异 &ensp;&ensp;&ensp;通过下面例子来看看AMD和CommonJS的语法上的区别。最初的源码，使用的是ES6规范：12345678910export default class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; printInfo () &#123; console.log(`Name: &#123;this.age&#125;, age: &#123;this.age&#125;`); &#125;&#125; &ensp;&ensp;&ensp;babel默认情况下产生的输出如下：1234567891011121314151617181920212223242526272829\"use strict\";Object.defineProperty(exports, \"__esModule\", &#123; value: true&#125;);var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125;var Person = function () &#123; function Person(name, age) &#123; _classCallCheck(this, Person); this.name = name; this.age = age; &#125; _createClass(Person, [&#123; key: \"printInfo\", value: function printInfo() &#123; console.log(\"Name: &#123;this.age&#125;, age: &#123;this.age&#125;\"); &#125; &#125;]); return Person;&#125;();exports.default = Person; &ensp;&ensp;&ensp;这其实是CommonJS的语法格式。如果想要生成AMD格式的，需要借助babel-plugin-transform-es2015-modules-amd插件。输出如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051define([\"exports\"], function (exports) &#123; \"use strict\"; Object.defineProperty(exports, \"__esModule\", &#123; value: true &#125;); function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125; &#125; var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;(); var Person = function () &#123; function Person(name, age) &#123; _classCallCheck(this, Person); this.name = name; this.age = age; &#125; _createClass(Person, [&#123; key: \"printInfo\", value: function printInfo() &#123; console.log(\"Name: &#123;this.age&#125;, age: &#123;this.age&#125;\"); &#125; &#125;]); return Person; &#125;(); exports.default = Person;&#125;); &ensp;&ensp;&ensp;随着ES6标准的发布，在ES6中已经原生支持了模块化的功能。所有可以在代码中使用ES6的原生模块化的语法。 &ensp;&ensp;&ensp;有时我们需要关注产出物的模块管理方式，这样在使用的时候才不会出现各种问题。Babel只做了源码转译的工作，每一个输入文件对应一个输出文件，所以我们需要一个将这些输出文件打包成一个文件的工具，也就是webpack。 Babel&ensp;&ensp;&ensp;Babel是一个让开发者可以用新特性编写代码，同时又能运行的一个工具。主要是弥补上述提及的新标准和浏览器支持度之间的鸿沟。它的主要设计思想是插件化。 &ensp;&ensp;&ensp;Babel有几种运行方式： 命令行的方式，通过babel-cli 运行在node环境下，通过babel-node 运行在源码中，通过babel-register &ensp;&ensp;&ensp;在上面章节中，我们使用了插件babel-plugin-transform-es2015-modules-amd来生成AMD格式的代码。使用插件的方式可以通过命令行，比如：1babel --plugins transform-es2015-modules-amd .\\src.js -o dst.js &ensp;&ensp;&ensp;或者也可以使用.babelrc配置文件来进行配置，比如：1234&#123; \"presets\": [\"es2015\"], \"plugins\": [\"transform-es2015-modules-amd\"]&#125; &ensp;&ensp;&ensp;还有一些配置可以参照官方文档。 Webpack&ensp;&ensp;&ensp;Webpack是个打包工具，同时也会管理模块的依赖关系。是目前比较主流的打包工具。webpack本身也是使用模块化的方法去打包，同时也是插件化的组织方式。具有以下几个特点： 代码拆分（code splitting） 静态分析 模块热替换（Hot Module Replacement） &ensp;&ensp;&ensp;打包后的文件可直接被使用。但是同时有一点需要注意的是，就是打包后的文件格式采取的模块化管理方式。为了将bundle适应不同的运行时环境，通过output.libraryTarget选项，webpack支持将bundle打包成不同格式的模块化代码。具体设置可以参考此链接。","categories":[{"name":"前端","slug":"前端","permalink":"http://codingeek.me/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codingeek.me/tags/JavaScript/"}]},{"title":"JavaScript的19个精简语法","slug":"JavaScript的19个精简语法","date":"2017-06-25T07:31:12.000Z","updated":"2017-07-09T02:24:20.743Z","comments":true,"path":"2017/06/25/JavaScript的19个精简语法/","link":"","permalink":"http://codingeek.me/2017/06/25/JavaScript的19个精简语法/","excerpt":"","text":"三元操作符简短写法 短路计算简短写法 变量声明简短写法 If控制语句简短写法 for控制语句简短写法 短路计算 基于十进制的指数 对象属性 箭头函数 隐示返回值 默认参数 模板字面量 解构赋值 字符串换行 …操作符 强制参数 Array.find Obejct[key] Double Bitwise NOT 三元操作符简短写法Longhand:12345678const x = 20;let big;if (x &gt; 10) &#123; big = true;&#125; else &#123; big = false;&#125; Shorthand:1const big = x &gt; 10 ? true : false; 或者嵌套：1const big = x &gt; 10 ? \" greater 10\" : x &lt; 5 ? \"less 5\" : \"between 5 and 10\"; 个人认为最后一个可读性较差，不建议使用。 短路计算简短写法Longhand:123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; let variable2 = variable1;&#125; Shorthand:1const variable2 = variable1 || 'new'; 这个很厉害了，大部分人都不太清楚，至少我自己也是。但是它确实可以写成这样。 1234567let variable1;let variable2 = variable1 || '';console.log(variable2 === ''); // prints truevariable1 = 'foo';variable2 = variable1 || '';console.log(variable2); // prints foo 变量声明简短写法Longhand:123let x;let y;let z = 3; Shorthand:1let x, y, z=3; If控制语句简短写法Longhand:1if (likeJavaScript === true) Shorthand:1if (likeJavaScript) Longhand:1234let a;if ( a !== true ) &#123;// do something...&#125; Shorthand:1234let a;if ( !a ) &#123;// do something...&#125; for控制语句简短写法Longhand:1for (let i = 0; i &lt; allImgs.length; i++) Shorthand:1for (let index in allImgs) 对于Array：12345678function logArrayElements(element, index, array) &#123; console.log(\"a[\" + index + \"] = \" + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 短路计算Longhand:123456let dbHost;if (process.env.DB_HOST) &#123; dbHost = process.env.DB_HOST;&#125; else &#123; dbHost = 'localhost';&#125; Shorthand:1const dbHost = process.env.DB_HOST || 'localhost'; 基于十进制的指数Longhand:1for (let i = 0; i &lt; 10000; i++) &#123;&#125; Shorthand:123456789for (let i = 0; i &lt; 1e7; i++) &#123;&#125;// All the below will evaluate to true1e0 === 1;1e1 === 10;1e2 === 100;1e3 === 1000;1e4 === 10000;1e5 === 100000; 对象属性以下是对于ES6之后的。 Longhand:1const obj = &#123; x:x, y:y &#125;; Shorthand:1const obj = &#123; x, y &#125;; 箭头函数这应该属于ES6的语法上的使用 Longhand:1234567891011function sayHello(name) &#123; console.log('Hello', name);&#125;setTimeout(function() &#123; console.log('Loaded')&#125;, 2000);list.forEach(function(item) &#123; console.log(item);&#125;); Shorthand:12345sayHello = name =&gt; console.log('Hello', name);setTimeout(() =&gt; console.log('Loaded'), 2000);list.forEach(item =&gt; console.log(item)); 隐示返回值这也是ES6的箭头函数的语法。 Longhand:123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125; Shorthand:123calcCircumference = diameter =&gt; ( Math.PI * diameter;) 默认参数ES6的支持。 Longhand:1234567function volume(l, w, h) &#123; if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h;&#125; Shorthand:12volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);volume(2) //output: 24 模板字面量ES6的支持。 Longhand:12const welcome = 'You have logged in as ' + first + ' ' + last + '.'const db = 'http://' + host + ':' + port + '/' + database; Shorthand:12const welcome = `You have logged in as $&#123;first&#125; $&#123;last&#125;`;const db = `http://$&#123;host&#125;:$&#123;port&#125;/$&#123;database&#125;`; 解构赋值ES6的支持。 Longhand:123456789const observable = require('mobx/observable');const action = require('mobx/action');const runInAction = require('mobx/runInAction');const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity; Shorthand:12import &#123; observable, action, runInAction &#125; from 'mobx';const &#123; store, form, loading, errors, entity &#125; = this.props; 字符串换行Longhand:123456const lorem = 'Lorem ipsum dolor sit amet, consectetur\\n\\t' + 'adipisicing elit, sed do eiusmod tempor incididunt\\n\\t' + 'ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t' + 'veniam, quis nostrud exercitation ullamco laboris\\n\\t' + 'nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t' + 'irure dolor in reprehenderit in voluptate velit esse.\\n\\t' Shorthand:123456const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.` …操作符ES6的支持。 Longhand:1234567// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice() Shorthand:12345678// joining arraysconst odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr]; 或者这样：12const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6]; 这样：1234const &#123; a, b, ...z &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a) // 1console.log(b) // 2console.log(z) // &#123; c: 3, d: 4 &#125; 在ES6之前可能就要用到Array.concat和Object.Assign，但是没那么方便。 强制参数默认情况下，如果没有对函数的参数传入值，JavaScript将函数的参数设置为undefined，所以很多情况下会对函数的参数进行检测。 Longhand:123456function foo(bar) &#123; if(bar === undefined) &#123; throw new Error('Missing parameter!'); &#125; return bar;&#125; Shorthand:1234567mandatory = () =&gt; &#123; throw new Error('Missing parameter!');&#125;foo = (bar = mandatory()) =&gt; &#123; return bar;&#125; Array.findLonghand:12345678910111213const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,]function findDog(name) &#123; for(let i = 0; i&lt;pets.length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === name) &#123; return pets[i]; &#125; &#125;&#125; Shorthand:12pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy');console.log(pet); // &#123; type: 'Dog', name: 'Tommy' &#125; Obejct[key]Longhand:123456789function validate(values) &#123; if(!values.first) return false; if(!values.last) return false; return true;&#125;console.log(validate(&#123;first:'Bruce',last:'Wayne'&#125;)); // true Shorthand:123456789101112131415161718192021222324// object validation rulesconst schema = &#123; first: &#123; required:true &#125;, last: &#123; required:true &#125;&#125;// universal validation functionconst validate = (schema, values) =&gt; &#123; for(field in schema) &#123; if(schema[field].required) &#123; if(!values[field]) &#123; return false; &#125; &#125; &#125; return true;&#125;console.log(validate(schema, &#123;first:'Bruce'&#125;)); // falseconsole.log(validate(schema, &#123;first:'Bruce',last:'Wayne'&#125;)); // true Double Bitwise NOTLonghand:1Math.floor(4.9) === 4 //true Shorthand:1~~4.9 === 4 //true","categories":[{"name":"前端","slug":"前端","permalink":"http://codingeek.me/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://codingeek.me/tags/JavaScript/"},{"name":"翻译","slug":"翻译","permalink":"http://codingeek.me/tags/翻译/"}]},{"title":"librdkafka源码分析","slug":"librdkafka源码分析","date":"2017-04-16T08:24:53.000Z","updated":"2017-04-17T12:05:25.639Z","comments":true,"path":"2017/04/16/librdkafka源码分析/","link":"","permalink":"http://codingeek.me/2017/04/16/librdkafka源码分析/","excerpt":"","text":"介绍librdkafka是Apache Kafka的一个C/C++客户端。里面包含了一个C的客户端和一个封装C的C++客户端。两者总的代码行数超过3万行。算起来也是不小。 我准备从以下几个方面入手，简单分析下C客户端代码的整体结构与线程模型。 线程模型 几种重要的队列（queue） 主要分析Consumer的执行流 未涉及的包括： Producer的执行流 数据交互的格式以及打包与解包 Client group 大部分代码都是以C编写的，从我阅读后来看，整体的代码编写风格很随意，没有固定的代码风格。这可能也会在阅读过程中增加一点难度，第二是C风格的代码免不了宏，因此在分析的时候需要逐一分析，这样代码的上下文很容易丢失。 阅读的代码为windows平台。 线程模型有以下几个线程： 主处理线程当调用rd_kafka_new时，会传入创建rd_kafka_t对象的类型，也就是RD_KAFKA_CONSUMER或者RD_KAFKA_PRODUCER。之后会调用rd_kafka_cgrp_new创建rd_kafka_cgrp_t对象，接着就是创建主处理线程，线程的入口为rd_kafka_thread_main。 rd_kafka_thread_main中会从rd_kafka_t对象中的操作队列rk_ops中逐一取出进行操作。操作的数据结构类型为rd_kafka_op_t。操作类型有很多种，参考rd_kafka_op_type_t。操作执行完后调用rd_kafka_op_handle回调。 这是rd_kafka_thread_main线程的主要工作，其中有一些细节这里未涉及。 Broker线程上述rd_kafka_thread_main线程创建完后，调用rd_kafka_broker_add创建internal broker线程。broker线程的类型有三种，分别是： RD_KAFKA_CONFIGURED根据用户配置，生成的broker线程 RD_KAFKA_LEARNED内部使用的broker线程，主要针对Client Group使用 RD_KAFKA_INTERNAL内部使用的broker线程 Broker线程主要执行的是针对Broker的当前内部状态，比如INIT、DOWN、CONNECT、UP等，在这些状态下，执行针对的操作。比如在RD_KAFKA_BROKER_STATE_UP状态下，根据rk_type（类型为rd_kafka_type_t）来执行rd_kafka_broker_producer_serve或者rd_kafka_broker_consumer_serve。 Broker线程可能会有多个。 队列队列在librdkafka的数据流转中起到了关键性的作用。主要有：12345rd_kafka_q_t *rktp_ops;rd_kafka_q_t *rktp_fetchq;rd_kafka_q_t *rkcg_q;rd_kafka_q_t *rk_rep;rd_kafka_q_t *rkcg_q; buf队列有以下几个：123rd_kafka_bufq_t rkb_outbufs;rd_kafka_bufq_t rkb_waitresps;rd_kafka_bufq_t rkb_retrybufs; 在创建rd_kafka_cgrp_t对象时，将rkcg_q设置为rk_rep的转发队列（forward queue）1rd_kafka_q_fwd_set(rk-&gt;rk_rep, rkcg-&gt;rkcg_q); 在线程rd_kafka_broker_thread_main里，调用rd_kafka_toppar_op_fetch_start设置rktp_fetchq的转发queue为rkcg_q。 在Broker线程中，rd_kafka_fetch_reply_handle会创建一个临时的queue，然后创建一个rko，将rko压入到临时队列的rkq_q对象中。1rd_kafka_q_enq(rkq, rko) 最后将这个临时queue压入到rd_kafka_toppar_s::rktp_fetchq的转发queue中，也就是rkcg_q。 Broker 线程会调用rd_kafka_broker_consumer_serve，然后到rd_kafka_broker_fetch_toppars构建一个rd_kafka_buf_t *对象，同时将此对象的rkbuf_cb设置为rd_kafka_broker_fetch_reply。然后将buf压入到broker的rkb_outbufs队列中。 在rd_kafka_send会从rkb_outbufs获取buf发送之后，会将此buf压入到rkb_waitresps队列中。 收到回应后，会调用rkbuf_cb会被调用rd_kafka_buf_callback的request，就是rkbuf。rkb-&gt;rkb_waitresps的rkbq_bufs中，通过corrid查找相应的rd_kafka_buf_t对象找到后更新状态。1rd_kafka_bufq_deq(&amp;rkb-&gt;rkb_waitresps, rkbuf); Consumer执行流消费者主动去poll消息1rd_kafka_consume0(rk, rkcg-&gt;rkcg_q, timeout_ms); rkcg_q就是rk_rep的转发queue。从rkcg_q取出一个rd_kafka_op_t对象，再从rd_kafka_op_t对象中取得消息（rd_kafka_message_t）。 总结这个库的代码结构相对来说还是比较复杂的。上面的分析也很粗糙，有很多细节没有说明。但是大方向有了，其他的细节相分析起来，就会游刃有余，而不是毫无头绪。这个库有一点不好的是队列的转发操作，说白了就是互相保存对象地址，然后在其他地方操作，所以不是很直观。在没弄清楚的情况会让人摸不着头脑。一般我自己在阅读源码时，会遵循以下几个步骤： 有一个可运行的示例 理解线程模型 大致阅读相关数据结构 将示例的执行流串起来 抓包查看如何通讯 然后与以往看过的源码进行一个对比。从代码风格，代码格式化，代码的数据结构，API等方面进行比较。","categories":[{"name":"编程","slug":"编程","permalink":"http://codingeek.me/categories/编程/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://codingeek.me/tags/源码分析/"},{"name":"开源","slug":"开源","permalink":"http://codingeek.me/tags/开源/"}]},{"title":"防火墙、VPN与MTU","slug":"防火墙、VPN与MTU","date":"2017-04-09T02:06:06.000Z","updated":"2017-04-09T02:37:46.947Z","comments":true,"path":"2017/04/09/防火墙、VPN与MTU/","link":"","permalink":"http://codingeek.me/2017/04/09/防火墙、VPN与MTU/","excerpt":"","text":"问题因为行业原因，之前理解中的软件都是跑在局域网内，数据的传输至少不会遇上网络方面的原因，除去一些硬件等物理因素。这是常规的用法，测试团队也是基于这样的网络环境进行测试，也包括防火墙。 编程方面有一句名言： 永远不要假设编程。 我所理解的是，除去我们能够想到的（也就是我们假设的）正常case外，应该尽量地考虑其他case，包括边界case和环境因素。恰恰大部分人（有些时候包括我自己）平常所进行的都是假设编程。 工程团队的一个现场：一个调控中心（称为C），多个采集站（称为S）。C和S是异地，中间有防火墙，数据通过VPN走公网。当时是10个采集站。报告说有几个站数据一直时好时坏。 远程登录后，用procexp看了下，有几个站在进行疯狂的重连（用的是TCP协议）。一个链路建立没多久就被关闭，然后又新建一个链路。第一反应是感觉很蹊跷，想到的是会不会超时时间过短？在前面一个链路未完全建立的情况下超时了，导致主动断开又重连。 但是反过来又说不通，因为其他几个站的数据完好，且用的是同样的超时时间。（正因为上述的假设，没考虑到网络延时因素）后来用wireshark抓包看了下，有些情况下是采集站主动关闭链路，有些时候又不是。其中有个规律是，采集站主动关闭的前一刻，有个超大的数据包从C发往S。而这种情况在数据好的采集站中未发现过。 原因经过后续的询问与调查，发现C与S数据未通的几个站的网络延时相对来说非常高，基本在150ms以上。可以确定是C这端的数据粘连成一个很大的数据包，这个很大的数据通过防火墙后，被防火墙丢弃了，因为数据包大小超过了MTU值。导致S端认为链路出现了状况，进行了主动关闭。关于走VPN导致数据不稳定的情况，网上有很多帖子。情况基本一致。 解决方案方法就是调整MTU的值。防火墙的设置基本是固定的，1500。所以能想到的是改变主机的MTU。以下是在Windows平台的操作。首先是找到发包相应的网络适配器名称：netsh interface ipv4 show subinterface 找到名称后，进行修改：netsh interface ipv4 set subinterface “网络A” mtu = 1400 store=persistent 总结基于很多现实原因，测试环境无法和真实的生产环境一致，以及大部分时候开发人员的假设编程等情况。综合各种情况，在特定的场景中会一些我们无法预料的到情况。反过来看，从各种意外状况，需要反省，不管是测试用例，测试场景还是开发时的思维模式。因为这些都是正反馈，有反馈才能有目的的改善。","categories":[{"name":"编程","slug":"编程","permalink":"http://codingeek.me/categories/编程/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://codingeek.me/tags/杂谈/"}]},{"title":"python的ctype与dll的交互2","slug":"python的ctype与dll的交互2","date":"2017-03-12T02:11:21.000Z","updated":"2017-03-12T03:11:01.923Z","comments":true,"path":"2017/03/12/python的ctype与dll的交互2/","link":"","permalink":"http://codingeek.me/2017/03/12/python的ctype与dll的交互2/","excerpt":"","text":"摘要上一篇文章说了python与dll交互间的数据结构问题。这篇文章说下dll中的回调问题。介绍python的c回调的文章网上有很多，但很多都是无法工作。因此在此记录下整个过程。 C的回调通常c写的回调都是类似这样的结构：12345678struct A_s&#123; const char* a1; unsigned int a2;&#125;;typedef struct A_s A_t;TESTDLL_API int function1(void (*outputcallback)(const A_t* a, void* b), void* param); 在c或者C++中调用的话，第一个参数可以传入一个签名匹配到回调的方法或者lambda对象（Lambda参考这篇）。 python的回调在python中，需要定义相应的数据结构，接下来就是回调的原型定义。123456class A(Structure): _fields_ = [ (\"a1\", c_char_p), (\"a2\", c_int)]CMPFUNC = CFUNCTYPE(None, POINTER(A), c_void_p) CFUNCTYPE的第一个参数是回调的返回值，接下是回调的参数。有一点需要注意的是，任何传入c接口的参数都是ctypes类型，而不是python的内置内类。1self.dllModule.function1(self.cb, c_int(10)) 回调中的第一个参数是一个对象，这个对象包含了一个contents字段，在这个字段中才是我们自定义的字段。1234def callback(self, a, b): print(dir(a)) print(a.contents.a1, a.contents.a2) print(b) 源码源码在这里","categories":[{"name":"编程","slug":"编程","permalink":"http://codingeek.me/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://codingeek.me/tags/python/"},{"name":"dll","slug":"dll","permalink":"http://codingeek.me/tags/dll/"}]},{"title":"Callback in C and C++","slug":"Callback-in-C-and-C","date":"2017-03-04T02:24:54.000Z","updated":"2017-03-04T05:08:46.151Z","comments":true,"path":"2017/03/04/Callback-in-C-and-C/","link":"","permalink":"http://codingeek.me/2017/03/04/Callback-in-C-and-C/","excerpt":"","text":"动机前面一段时间一直在看g3log和libuv的源码。在看完也写了点例子操作后，看到g3log里面只有FileSink，因此想自己写一个SocketSink，这个版本实现只是功能上的实现。 问题因为g3log是C++11开发的，但是libuv库又是一个C库，而且是大量使用回调的模式的事件驱动库。因此两者的结合看起来很奇怪。站在使用者角度，当然是使用C++11风格的好。但是在试过以下代码，发现C++11的Lambda好像和C的回调不是那么匹配。12345auto connect_cb = [](uv_connect_t* req, int status) &#123; uv_read_start((uv_stream_t*)req-&gt;handle, on_alloc, on_read);&#125;; uv_tcp_connect(&amp;con_req, client, (const sockaddr*)&amp;addr, connect_cb); 在VS2010中编译不通过，原因是因为Lambda在生成Closure的时候使用了上下文，而C的回调刚好和调用的上下文无关的。因此无法将function形式的函数转换成函数指针。但是在VS2015中则可以。 但是又存在另一个问题，就是如果想要将on_alloc和on_read也使用Lambda就会存在问题，因为在connect_cb内部使用的话：12345678910auto alloc_cb = [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) &#123; buf-&gt;base = (char*)malloc(suggested_size); buf-&gt;len = suggested_size;&#125;;auto connect_cb = [](uv_connect_t* req, int status) &#123; uv_read_start((uv_stream_t*)req-&gt;handle, alloc_cb, on_read);&#125;;uv_tcp_connect(&amp;con_req, client, (const sockaddr*)&amp;addr, connect_cb); 就需要capture为引用或者拷贝，这样就导致了在使用connect_cb会报出类似： error C3493: ‘alloc_cb’ cannot be implicitly captured because no default capture mode has been specifiederror C2664: ‘int uv_tcp_connect(uv_connect_t ,uv_tcp_t ,const sockaddr *,uv_connect_cb)’: cannot convert argument 4 from ‘int’ to ‘uv_connect_cb’ 这样的错误。但是在connect_cb中使用[&amp;] capture，又会导致 error C2664: ‘int uv_tcp_connect(uv_connect_t ,uv_tcp_t ,const sockaddr *,uv_connect_cb)’: cannot convert argument 4 from ‘run_tcp_client::‘ to ‘uv_connect_cb’ 陷入了两难境地。google了一把，就想将一些东西记录在这。 回调传统方案大部分想到的是传统方案，也就是使用接口类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//------------------------------------------------------------------------// Abstract Base Class// Those who want to provide a callback must derive from this class and// provide an implementation of cbiCallbackFunction().class CallbackInterface&#123;public: // The prefix \"cbi\" is to prevent naming clashes. virtual int cbiCallbackFunction(int) = 0;&#125;;//------------------------------------------------------------------------// \"Caller\" allows a callback to be connected. It will call that callback.class Caller&#123;public: // Clients can connect their callback with this void connectCallback(CallbackInterface *cb) &#123; m_cb = cb; &#125; // Test the callback to make sure it works. void test() &#123; printf(\"Caller::test() calling callback...\\n\"); int i = m_cb -&gt; cbiCallbackFunction(10); printf(\"Result (20): %d\\n\", i); &#125;private: // The callback provided by the client via connectCallback(). CallbackInterface *m_cb;&#125;;//------------------------------------------------------------------------// \"Callee\" can provide a callback to Caller.class Callee : public CallbackInterface&#123;public: // The callback function that Caller will call. int cbiCallbackFunction(int i) &#123; printf(\" Callee::cbiCallbackFunction() inside callback\\n\"); return 2 * i; &#125;&#125;;//------------------------------------------------------------------------ 使用方法：12345678Caller caller;Callee callee;// Connect the callbackcaller.connectCallback(&amp;callee);// Test the callbackcaller.test(); 优点： 如果要处理多个回调，可以直接往接口类里添加 清晰简单 缺点： 接口可能存在名字冲突 只能继承一次 函数指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//------------------------------------------------------------------------// Callback function pointer.typedef int(*CallbackFunctionPtr)(void*, int);//------------------------------------------------------------------------// \"Caller\" allows a callback to be connected. It will call that callback.class Caller&#123;public: // Clients can connect their callback with this. They can provide // an extra pointer value which will be included when they are called. void connectCallback(CallbackFunctionPtr cb, void *p) &#123; m_cb = cb; m_p = p; &#125; // Test the callback to make sure it works. void test() &#123; printf(\"Caller::test() calling callback...\\n\"); int i = m_cb(m_p, 10); printf(\"Result (20): %d\\n\", i); &#125;private: // The callback provided by the client via connectCallback(). CallbackFunctionPtr m_cb; // The additional pointer they provided (it's \"this\"). void *m_p;&#125;;//------------------------------------------------------------------------// \"Callee\" can provide a callback to Caller.class Callee&#123;public: // This static function is the real callback function. It's compatible // with the C-style CallbackFunctionPtr. The extra void* is used to // get back into the real object of this class type. static int staticCallbackFunction(void *p, int i) &#123; // Get back into the class by treating p as the \"this\" pointer. ((Callee *)p) -&gt; callbackFunction(i); &#125; // The callback function that Caller will call via // staticCallbackFunction() above. int callbackFunction(int i) &#123; printf(\" Inside callback\\n\"); return 2 * i; &#125;&#125;; 使用方法：123456789Caller caller;Callee callee;// Connect the callback. Send the \"this\" pointer for callee as the // void* parameter.caller.connectCallback(Callee::staticCallbackFunction, &amp;callee);// Test the callbackcaller.test(); 优点： 和C风格的回调兼容 缺点： 实现优点复杂，优点绕 C++11 Lambda123456789101112131415161718192021222324252627282930313233343536373839404142class Callee&#123;public: Callee(int i) : m_i(i) &#123; &#125; // The callback function that Caller will call. int callbackFunction(int i) &#123; printf(\" Callee::callbackFunction() inside callback\\n\"); return m_i * i; &#125;private: // To prove \"this\" is indeed valid within callbackFunction(). int m_i;&#125;;//------------------------------------------------------------------------typedef std::function&lt;int(int)&gt; CallbackFunction;class Caller&#123;public: // Clients can connect their callback with this. void connectCallback(CallbackFunction cb) &#123; m_cb = cb; &#125; // Test the callback to make sure it works. void test() &#123; printf(\"Caller::test() calling callback...\\n\"); int i = m_cb(10); printf(\"Result (50): %d\\n\", i); &#125;private: // The callback provided by the client via connectCallback(). CallbackFunction m_cb;&#125;; 使用方法：12345678910Caller caller;Callee callee(5);// Connect the callback. Like with the C-style function pointer and // static function, we use a lambda to get back into the object.caller.connectCallback( [&amp;callee](int i) &#123; return callee.callbackFunction(i); &#125;);// Test the callbackcaller.test(); 模板函子实现在这：http://www.tutok.sk/fastgl/callback.html。可以用C++11的可变模板实现。 解决方案最终要解决上述的问题是，要解决capture的问题。解决方案是引入一个“bounce”函数。解决上下文问题。12345678static auto/*static std::function&lt;void(uv_connect_t* req, int status)&gt;*/ connect_bounce = [&amp;](uv_connect_t* req, int status) &#123; uv_read_start((uv_stream_t*)req-&gt;handle, alloc_cb, read_cb); &#125;;auto connect_cb = [](uv_connect_t* req, int status) &#123; connect_bounce(req, status);&#125;; 这样，alloc_cb和read_cb就可以使用正常的lambda了。 #引用 http://tedfelix.com/software/c++-callbacks.html http://www.alecjacobson.com/weblog/?p=3779 https://www.cabbages-and-kings.net/2014/08/11/c_style_callbacks_with_c_functions.html","categories":[{"name":"编程","slug":"编程","permalink":"http://codingeek.me/categories/编程/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"http://codingeek.me/tags/CPP/"}]},{"title":"g3log源码分析","slug":"g3log源码分析","date":"2017-02-17T01:42:49.000Z","updated":"2017-02-17T03:31:51.588Z","comments":true,"path":"2017/02/17/g3log源码分析/","link":"","permalink":"http://codingeek.me/2017/02/17/g3log源码分析/","excerpt":"","text":"源代码地址：github 代码量 从代码量上看，代码不是很多，所以整个库的结构也不会太复杂。首先从整体上有个概念，就需要看下整个库的类结构如何，以及类间的关系如何。 结构头文件结构通过VS2015的头文件依赖图，从整体的头文件依赖结构上看下整个工程是如何依赖的 主要类首先是LogWorker，这是库的核心类，包含了创建LogWorker实例的静态方法：1static std::unique_ptr&lt;LogWorker&gt; createLogWorker(); 以及构建本地log日志文件信息和Sink的方法：1234567std::unique_ptr&lt;FileSinkHandle&gt; addDefaultLogger( const std::string&amp; log_prefix, const std::string&amp; log_directory, const std::string&amp; default_id = \"g3log\"); template&lt;typename T, typename DefaultLogCall&gt;std::unique_ptr&lt;g3::SinkHandle&lt;T&gt;&gt; addSink(std::unique_ptr&lt;T&gt; real_sink, DefaultLogCall call); 最后就是保存日志的两个方法，一个是正常的保存，一个是异常的保存：12void save(LogMessagePtr entry);void fatal(FatalMessagePtr fatal_message); 内部还有一个私有的实现impl：1LogWorkerImpl _impl; LogWorkerImpl内部保存了Sink的的列表，以及一个C++11线程的Active对象。也是这个log库号称异步的原因。线程的Active实现如下：12345678910111213141516171819202122232425262728293031323334353637typedef std::function&lt;void() &gt; Callback; class Active &#123; private: Active() : done_(false) &#123;&#125; // Construction ONLY through factory createActive(); Active(const Active &amp;) = delete; Active &amp;operator=(const Active &amp;) = delete; void run() &#123; while (!done_) &#123; Callback func; mq_.wait_and_pop(func); func(); &#125; &#125; shared_queue&lt;Callback&gt; mq_; std::thread thd_; bool done_; public: virtual ~Active() &#123; send([this] &#123; done_ = true;&#125;); thd_.join(); &#125; void send(Callback msg_) &#123; mq_.push(msg_); &#125; /// Factory: safe construction of object before thread start static std::unique_ptr&lt;Active&gt; createActive() &#123; std::unique_ptr&lt;Active&gt; aPtr(new Active()); aPtr-&gt;thd_ = std::thread(&amp;Active::run, aPtr.get()); return aPtr; &#125; &#125;; 整体的思路就是维护一个消息queue，然后在run中不停地从queue中取对象执行。当queue中没有消息时，run会等待在mq_.wait_and_pop(func)这里。 LogWorker的save和fatal是将消息转发给LogWorkerImpl的后台线程去执行，具体执行的是LogWorkerImpl的bgSave和bgFatal。而这两个方法最后都会传递给Sink&lt;T&gt;的实例的send去执行。接下来就是Sink的具体实现。源码中只实现了FileSink，也就是将日志消息保存到本地文件中。这个类的内部的fileWrite方法也是Thread Active最终要执行的执行体。 这里有个需要注意的地方。就是内部使用的Sink都是被封装成模板类Sink&lt;T&gt;（继承SinkWrapper接口）的实例，Sink&lt;T&gt;本身有两个方法：1234void send(LogMessageMover msg) override；template&lt;typename Call, typename... Args&gt;auto async(Call call, Args &amp;&amp;... args)-&gt; std::future&lt; typename std::result_of&lt;decltype(call)(T, Args...)&gt;::type&gt;(); 以及一个函数对象_default_log_call：123typedef std::function&lt;void(LogMessageMover) &gt; AsyncMessageCall;AsyncMessageCall _default_log_call; 保存的是最初传入的FileSink::fileWrite。 第一个方法是对SinkWrapper接口API的实现。而第二个方法则是返回给用户用于异步调用的。也就是SinkHandle&lt;T&gt;，其中的T就是Sink&lt;T&gt;。最后Sink&lt;FileSink&gt;保存在LogWorkerImpl的std::vector _sinks中。 最后一个就是LOG宏中用到的LogCapture。此类中包含了一条log日志的所有信息：12345678std::ostringstream _stream;std::string _stack_trace;const char *_file;const int _line;const char *_function;const LEVELS &amp;_level;const char *_expression;const g3::SignalType _fatal_signal; 在析构时，调用全局的：1saveMessage(_stream.str().c_str(), _file, _line, _function, _level, _expression, _fatal_signal, _stack_trace.c_str()); 进行日志保存。 全局方法包含以下几个全局设置的方法：12345void initializeLogging(LogWorker *logger);void setFatalPreLoggingHook(std::function&lt;void(void)&gt; pre_fatal_hook);void setFatalExitHandler(std::function&lt;void(FatalMessagePtr)&gt; fatal_call); 还有在namespace internal的：1void saveMessage(const char *entry, const char *file, int line, const char *function, const LEVELS &amp;level, const char *boolean_expression, int fatal_signal, const char *stack_trace) 线程模型一个主线程，一个LogWorkerImpl的后台线程，用于遍历Sink列表，然后每一个Sink&lt;T&gt;对应一个后台线程，用于日志存储。 123456789101112131415graph TB subgraph main createLogWorker--&gt;addDefaultLogger addDefaultLogger--&gt;initializeLogging end subgraph LogWorkerImpl bgSave--&gt;sink&apos;save end subgraph sink sink_bg--&gt;_default_log_call end LOG--&gt;saveMessage saveMessage--&gt;LogWork_save LogWork_save-- async --&gt;bgSave sink&apos;save-- async --&gt;sink_bg","categories":[{"name":"开源","slug":"开源","permalink":"http://codingeek.me/categories/开源/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://codingeek.me/tags/源码分析/"},{"name":"开源","slug":"开源","permalink":"http://codingeek.me/tags/开源/"}]},{"title":"ZeroMQ:理论基础","slug":"ZeroMQ-理论基础","date":"2017-02-12T01:56:32.000Z","updated":"2017-03-12T02:09:02.409Z","comments":true,"path":"2017/02/12/ZeroMQ-理论基础/","link":"","permalink":"http://codingeek.me/2017/02/12/ZeroMQ-理论基础/","excerpt":"","text":"介绍不像其他（中心式）基于容易理解的理论基础的消息传输系统。 几乎没有关于通用式分布式消息传输系统的资源，尤其是读者特别感兴趣的ØMQ。 这篇论文的目的是解释ØMQ架构的基本元素，他们是如何相互协调以及他们这样设计的理由。 #拓扑结构拓扑结构是ØMQ的主要概念。除非你真正理解“拓扑结构”是什么意思，否则其中出现的一些概念导致混淆以及难于理解，甚至导致设计不当。 作为一个非正式的定义，我们可以把“拓扑结构”理解成参与到业务逻辑的相同的方面的一组应用程序。 例如：考虑一个图片转换服务，将图片调整到所需的大小和分辨率。所有的应用程序都提供了转换服务，所有的应用程序都使用服务。所有的中间节点，比如负载均衡，形成了一个拓扑结构。 从技术层面来说，拓扑结构有以下属性： 拓扑是个图，图中的节点是应用程序，格子（lattices）是应用程序之间的数据通道。 所有的应用程序在业务逻辑方面都有一致的路线协议。 这个图是紧密连接的。也就是：任意两个节点要不是直接连通，要不就是通过其他中间节点间接连通。 第一点很明显。有一点需要指出的是，“通道（channel）”一词是故意使用，用来替代“连接（connection）”，来描述这个模型，甚至底层是无连接的传输，比如IP多播或UDP。 第二点说的是，在拓扑结构中，所有的应用程序都有一致消息传输（比如“图片需要调整大小”或“这是一张调整过大小的图片”），一致的消息序列（在应用程序中以状态机实现），实际的数据编码（图片数如何序列化的？RGB？CMYK？）等等。 第三点说的是，即使是有两个相同业务逻辑的部署，他们形成的也是两个拓扑结构，除非他们通过数据通道进行相互连接。 为了直观理解拓扑结构概念，重要的是理解fuzzy概念。同样fuzzy的是面向对象编程中的类。存在一个正式的定义解释类是数据成员和方法的集合。但是没有定义解释哪一部分的业务逻辑应该形成一个类，哪一部分不应该。完全依赖于程序员去决定哪个业务概念需要封装成类，哪个不需要。程序员可能会犯错，将所有的业务逻辑放到一个类中，因此几乎回避了面向对象设计；或者将逻辑分布到千万个小的类中，这就将程序员置于难以理解的相互关联的混乱之中。 同样地，没有一个单一的正确方式将业务逻辑划分到拓扑结构中。唯一的经验法则是，拓扑是扩展的原子单元。你可以将拓扑结构作为整体进行扩展，而不能只是扩展其某一方面。因此，如果你期待在将来需要将功能A与功能B相互独立，你应该直接为A单独创建一个拓扑结构，为B单独创建一个拓扑结构。 我们拿一个例子来阐述说明上述的概念：在我们的图片转换程序中，有两个基本功能：调整图片大小和调整图片的亮度。我们可以选择将这两个功能创建一个拓扑，或者为每个功能创建“大小调整”拓扑和“亮度调整”拓扑。 前面这种场合，我们需要定义某种路线传输方式来传达我们想要的功能。比如说，消息的第一个字节为1代表“大小调整”,2代表“亮度调整”。同时我们应该注意的是，这种设计导致这两个功能是紧密耦合的。如果在将来我们打算增加更多的处理节点，他们的每一个都应该实现这两个功能。 后面这种场合，这两个功能是不相交的。在消息中，没有必要设置特殊的字段来代表选择的功能，在“大小调整”拓扑中，所有的请求都是请求调整图片大小，在“亮度调整”拓扑中，所有的请求都是请求调整图片亮度。在这个设计中，我们可以独立扩展每个拓扑结构而不影响其他的拓扑。假设我们想设计一个专用的FPGA来调整图片大小，我们可以简单地将它们连接到“大小调整”拓扑结构，而不影响“亮度调整”拓扑。如下图。 客户端可以请求调整大小（通过拓扑A）和调整亮度（通过拓扑B），worker1只能调整图片大小，worker3只能调整图片亮度，而worker2可以提供调整图片大小和调整图片亮度两个功能。 最后关于拓扑结构要注意的是，由于很清晰地在拓扑结构之间进行了划分，就可以映射到底层的传输协议的某一方面，比如TCP端口。这就允许底层的网络按照业务规范其行为。比如，测量特定拓扑结构的带宽消耗（和特定的业务逻辑，比如调整图片大小服务的带宽消耗与调整图片亮度服务的带宽消耗）。可以基于拓扑结构进行流量调整。比如减少调整图片大小服务的带宽，用来增加调整图片亮度服务的带宽等等。 #传输经常会出现在不同的传输机制的上层，除了TCP之外，会要求运行一层消息层，比如InfiniBand（处于性能考虑），IP多播或者SCTP。原生的方法是开启一个TCP传输，然后在此之上增加一些TCP缺少的特性，比如心跳。在其他的底层传输之上提供一个相同的行为。这个方法有几个问题： 首先，在特定的协议之上，构造一个类TCP的包装器会变得很冗余。如果它的行为类似TCP，那为何不一开始就用TCP。（这条规则排除因为性能的原因） 其次，一些协议不能硬塞进TCP模型中。例如：IP广播。 基于上述特定的问题，ØMQ采用了不同的方案。底层的传输保持了各自的原生特性而不用提供一个共通的东西，在上层进行了一层封装。不同的是，ØMQ提供了一组最小的接口（消息界定，消息分割和消息原子性），同时要求上层足够的通用来处理底层各个不同的传输模式。实际中，它意味着在传输层之上有一层很”薄”的封装。例如消息界定协议（当封装TCP的时候）、消息分割协议（将长的消息分割成多个基于包传输的数据包）或late-joiner协议（当加入PGM多播流的时候，丢弃接收到消息的最后一部分） #拓扑结构的建立 VS. 消息路由网络栈的每一层都将网络传输中的一部分复杂进行了抽象。IP层抽象掉了需要查找到路由的目标主机。TCP抽象掉了网络内在的丢包属性，提供了 可靠性保证。ØMQ抽象掉了将要发送数据的需要指定的特定网络位置。消息被发送到拓扑结构中，而不是特定的一个端点。回忆一下，拓扑结构是和特定业务逻辑绑定的，这也就意味着，你从一个拓扑结构发送消息，你是要求这个拓扑结构给你提供特定的服务，比如是图片调整大小或者明亮度调整。ØMQ会以用户透明的方式选择一个真正的端点来接收消息。 为了落实这一原则，ØMQ严格区分了拓扑结构的建立（zmq_bind,zmq_connect）和实际消息的传输（zmq_send,zmq_recv）。前者处理底层的传输地址，比如IP地址，后者使用一个句柄（fd）去访问特定的拓扑结构。1234567/* Topology establishment */int s = zmq_socket (...);zmq_connect (s, \"tcp://192.168.0.111:5555\");/* Message routing */const char data [] = \"ABC\";zmq_send (s, data, sizeof (data), 0); 将拓扑结构的建立和消息的路由分开严格上说不是不可或缺的。毕竟，结合两个单一的函数很简单。1zmq_send (s, \"tcp://192.168.0.111:5555\", data, sizeof (data), 0); 区分开既有技术上的又有教育意义上的理由。技术上的理由是： 当我们想以异步的方式从拓扑结构中接收消息时，无论如何我们必须连接到它。没有理由不继续利用这个通道进行消息的发送。 将拓扑结构的建立和消息路由分开可以很好地映射到BSD的socket API（bind/connect VS. send/recv） 教育意义上的观点甚至更重要。它涉及到ØMQ是什么以及它不是什么。底层的协议，例如TCP，允许用户向特定的端点发送数据。ØMQ是构建在此基础之上，允许用户向特定的拓扑结构发送数据而不是特定的端点。因此，如果你想要向特定的端点发送数据，你应该使用TCP或者类似的协议。如果你想要将数据发送到拓扑结构，让拓扑结构来决定数据的最终端点，你应该使用ØMQ。 不幸的是，这个概念似乎很难去理解。其实，几乎不可能去说服用户ØMQ不能用于处理特定的端点，这个不是个bug而是个特性。将拓扑结构的建立和消息的路由分开没有解决这个问题，只是将实际的功能变得更显而易见。在这个特性中增加名称解析，希望能让事实变得更清晰。12zmq_connect (s, \"Brightness-Adjustment-Service\");zmq_send (s, data, sizeof (data), 0); #消息传输模式当谈及到拓扑结构作为消息路由的一种手段时，在不同的拓扑结构中的路由算法的区别就变得很清晰。“NASDAQ股票报价”拓扑结构将报价分布到拓扑中的每个消费者，“图片明亮度调整”拓扑结构将从客户端接收到的图片交给一个worker去转换，然后将调整过的图片发回给客户端。ØMQ通过定义几种不同的“消息传输模式”来反应这个事实。前面这个股票报价拓扑结构，就是发布/订阅模式的一个例子。后面这个图片明亮度调节拓扑结构就是一个请求/回复模式的一个例子。 消息传输模式既定义了用于节点间的通信协议，又定义了各个独立节点的功能。e.g.用于路由消息的算法。因此，不同的模式行为看上去像不同的协议。你不能将发布/订阅节点和请求/回复节点进行连接，就好像将TCP端点不能连接到SCTP端点一样。每一个拓扑结构都只实现了一个单一的消息传输模式。不存在一种方法将两个不同的消息传输模式的拓扑结构连接成一个拓扑结构。这个严格的区分对于拓扑结构作为一个整体来保证其行为是有必要的。只要你知道在拓扑结构中的每个端点都坚持提供发布/订阅语义，你就可以提供类似“消息会被投递在拓扑结构中的每个端点”的保证。如果拓扑结构的某一部分允许负载均衡而不是广播，你就不能做出上述那样的保证。更糟的是，消息传输模式是开放式的，你可能需要以一种完全任意的方式去扩展一个端点的行为，因此你没办法做出任何保证。下面是网络栈的示意图。需要注意的是，不同的消息传输模式都位于栈的同一层且相互间是独立的。 考虑到一些传统的消息传输系统选择提供通用的路由基础设施允许用户在此之上基本可以构建任意的路由算法（例如AMQP），而不是提供预包装的消息传递模式。所以有必要解释一下ØMQ选择后者的理由。 第一，设计一个功能齐全又没有bug的消息传输模式是很困难的任务。通过将创建模式的责任转交给用户，我们可以保证基于此消息传输系统构建的大部分应用在某些方面是有问题的。即使是这个模式实现是正确的，学习和开发的开销的成本将会超过使用预包装的消息传递模式的成本的数倍。毕竟，在DNS设计方面的一篇早期论文中提及：“[用户]想要的是使用这个系统所提供的功能，而不是理解。”第二，正式定义的模式允许执行一些需求，比如两个不同的模式不能在同一个拓扑结构中存在。消息传输系统可以检查对方是否也实现了相同的消息传输模式，如果不是则直接拒绝连接。如果由用户实现此类的模式，类似这样的检查很可能就不会存在。第三，通用的路由基础设施不能自动地支持分布式（别名：federated），这意味着只在简单的中心辐射型（hub-and-spoke）架构下才能工作，一旦想要超出这个模型，就必须要提供额外的信息。也就是回答类似“这个系统的消息传输模型是什么？”的问题。看一下基于AMQP的各类产品实现的“集群”机制。“模式”的特性依旧还存在，或者显示或者隐示（通过只支持一种模式）。最后，基于我们在AMQP的经验，尽管它提供了大量丰富的可能的消息传输模式，人们一次又一次的基于它实现相同的几个模式，而忽略了其他东西。 #Hop-by-Hop VS. End-to-End在网络栈中最巧妙的一个特性就是就是清晰的hopby-hop功能（IP）和end-to-end功能（TCP，UDP，SCTP等），也就是这个特性，将整个网络栈生态切分开，独立发展。如果没有这种功能的切分，end-to-end协议的每一个小改动对于IPv4和IPv6传输来说都是一种痛苦。这个想法的背后就是在网络传输过程中的每个节点都实现IP协议，然而，只有终端才会实现特殊的end-to-end协议，比如TCP。换句话说，中间节点，比如路由器，不需要知道在IP层之上的end-to-end协议。 将IP和TCP层切分的经验之后推广，形成了end-to-end argument形式。end-toend argument说的是，如果它的功能不能够被底层正确地提供（在我们的情况中就是hop-by-hop），也就是，它想要正常工作需要上层（end-to-end层）的协助，那么起初在底层实现也就没多大意义了。 ØMQ坚持end-to-end协议，将栈切分到hop-by-hop层（将节点用”X”开头表示）和end-to-end层（没有用”X”开头表示），这个和上述TCP/IP的拓扑图很像。 和TCP/IP同样的是，hop-by-hop层负责消息路由，end-to-end层可以提供附加的服务，比如可靠性，加密等。 然后我们不应该将TCP/IP的比喻用在此太过了，不像网络栈中的单hop-by-hop协议（IP）和多end-to-end（TCP，UDP，SCTP等），在ØMQ的每个end-to-end协议中都有它自己的hop-by-hop协议支撑。看起来像这样。 这样安排是因为每个消息模式的的路由功能（hop-by-hop提供）都是不一样的，不能再消息模式间共享。如果在未来碰到两个消息模式可以共享一个路由算法，而只在end-to-end的协议不同，那么我们也将会在单个hop-by-hop层之上，混合多个end-to-end协议。 最终，让我们来看下hop-by-hop VS. end-to-end的具体例子。REQ/REP模式指的是，客户端向多个worker服务端发送一个request请求，worker中的一个会处理这个请求然后产生一个reply，然后将reply发送给客户端。 hop-by-hop层要做的是将每个request请求发送到上游节点中的某一个（load-balancing），之后将reply发送给下游的接收到request的节点。 一切运行良好，直到worker处理request失败，或者因为网络的原因，整个拓扑结构的一部分脱离了整体。在这种情况下，客户端将会被阻塞，等待一个永远都不可能的reply。 为了解决这个问题，客户端需要设置一个超时，如果没有在超时时间内没有收到reply，就重发这个request。客户端也应该有能力过滤掉重复的reply。 现在回忆下end-to-end argument，重发功能没有端点的支持是不可能完成的，因此这个不太可能在hop-by-hop层进行实现。 最终我们得到的是，路由功能在hop-by-hop层实现，在此之上的end-to-end层实现可靠性。 #命名解析在写这篇文章的时间点，ØMQ不提供命名服务。为了加入到拓扑结构中，需要指定一个地址，比如IP地址和TCP端口。 在未来，我们可能会提供命名服务，将一个提供到拓扑结构的名字转换到底层的传输地址。比如，”Brightness-Adjustment-Service”可能被解析成”tcp://192.168.0.1111:5555”。 这里面需要注意的一个是命名解析服务的选择。比如当连接到”NASDAQ stock quotes”拓扑结构，用户想的是连接到本地的一个股票报价中心而不是NASDAQ自己，或者更糟的是，到竞争对手的股票报价中心。 通常情况下，命名解析服务都是通过DNS来实现。DNS是唯一个全球可用的分布式数据库。 #附录：设计模式[请参考原文] ##一致性原则 ##扩展性原则 ##新增插入原则 #总结这篇文章反应的架构是当前ØMQ的设计，在未来可能会存在变数。希望通过这篇文章能够介绍一些分布的消息传输，并且在这个领域的未来可以形成一些基础方面的共识。","categories":[{"name":"软件设计, 开源","slug":"软件设计-开源","permalink":"http://codingeek.me/categories/软件设计-开源/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://codingeek.me/tags/开源/"},{"name":"架构","slug":"架构","permalink":"http://codingeek.me/tags/架构/"}]},{"title":"过年","slug":"过年","date":"2017-02-09T13:34:23.000Z","updated":"2017-02-12T01:59:01.861Z","comments":true,"path":"2017/02/09/过年/","link":"","permalink":"http://codingeek.me/2017/02/09/过年/","excerpt":"","text":"过去小的时候，总是很期待过年。因为过年有新衣服，新鞋子穿，还可以见到爸爸妈妈。当然也有烦心的事情，就是寒假作业有很多。但终究还是期待来的多点。除了穿的、吃的，就是大家都聚集在爷爷奶奶家，吃饭，聊天，玩。能够感受到浓厚的家庭气氛。也自然觉得以后的每年都可以这样。 后来奶奶去世了，整个就变了，大家都不再齐聚在老房子里。不再有聊天，不再有大家坐在一起玩游戏，打扑克牌。之后爷爷也去世了。这个以爷爷奶奶为中心的家也就消失了。 听到越来越多的人说年还是那个年，但是味早已不是那个味。我也有同感，也一直在想我们为什么会有这种感觉。人的眼界在变，时代在变。只不过是之前的感觉，让那么多的变化给冲淡了。 现在现在也长大了，也不会再去期待年味如同小时候那一般。期待的是能和家人团聚在一起，谈谈一年来的事情，身边的变化。每当听闻村里的哪个哪个老人去世了，总会沉默一阵子，各种思绪都涌上心头。死亡无法逃避，只是太残忍。 时间没有终点，日复一日。年，只是一个让人体会自己变老，回忆逝去的人的契机。珍惜眼下。 将来将来也会成家，有小孩，希望自己的小孩能对过年有好的期待。能做一个好的自己。","categories":[{"name":"杂说","slug":"杂说","permalink":"http://codingeek.me/categories/杂说/"}],"tags":[]},{"title":"开源软件架构","slug":"开源软件架构","date":"2017-02-07T13:49:30.000Z","updated":"2017-02-12T00:33:07.951Z","comments":true,"path":"2017/02/07/开源软件架构/","link":"","permalink":"http://codingeek.me/2017/02/07/开源软件架构/","excerpt":"","text":"The Architecture of Open Source Applications: 英文地址中文翻译地址","categories":[{"name":"软件设计","slug":"软件设计","permalink":"http://codingeek.me/categories/软件设计/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://codingeek.me/tags/开源/"},{"name":"架构","slug":"架构","permalink":"http://codingeek.me/tags/架构/"}]},{"title":"python的ctype与dll的交互注意点","slug":"python的ctype与dll的交互","date":"2017-01-22T12:27:34.000Z","updated":"2017-03-12T02:37:40.535Z","comments":true,"path":"2017/01/22/python的ctype与dll的交互/","link":"","permalink":"http://codingeek.me/2017/01/22/python的ctype与dll的交互/","excerpt":"","text":"摘要这篇文章不会告诉读者如何去使用ctypes，如何使用ctypes在网上已经有很多重复、简单的例子。这篇文章只是记录自己在实际开发中，使用python测试一个dll模块中遇到的各种问题以及解决办法 注意点网络上已经有很多关于ctypes如何与dll交互的文章，大多数也都是点到为止。比如基本类型的使用，指针与引用的处理。但是在实际编程过程中，这里面还有很多细节点需要注意。 版本匹配这里要求的是安装的python版本位数与交互的dll的编译版本位数要一致。否则在python加载dll时会提示加载失败。 数据类型很多博客中已经提及了日常所用的一些C的数据类型，比如c_int,c_long。但是如果用C++开发，且同时用了windows类型，COM类型，那么很明显，基本类型是不够的，自己写class又繁琐。例如VARIANT，FILETIME。这些都是已知的类型。那么就需要导入相应的包。windows类型需要相应的wintypes；COM类型可以借助comtypes包。 运行环境 我自己在开发中使用的python3.X，3.X默认的是使用Unicode。如果dll内部接收的是ASCII的字符串，那么就需要先进行转换，再调用API。可以使用create_string_buffer()进行转换。 如果python加载的dll同时还依赖其他的dll，如果不做任何处理，python加载dll时会提示加载失败。原因是python会从python.exe的目录查找被依赖的dll，结果当然就是找不到，所以失败。解决办法有两个：第一个是将被依赖的dll的目录加入到环境变量中；第二个是将被依赖的所有dll拷贝到python.exe目录。 在dll代码中，可能存在参数为const char*类型，调用方传入nullptr或者NULL的情况。此时python运行期会提示错误。原因没有调查，不得而知。变通方案就是将传入的nullptr改成””。 如果dll的导出API接收const char*类型，而python又需要传入一个空字符串。如果直接使用””，在dll代码中使用param == ‘\\0’将会失败。具体原因未知，但是通过调试，dll端接收到的却是是长度为0的字符串。变通方案就是在dll端用再用长度判断一下。 在dll端，我们很大概率会使用结构体存储一个结构。比如下面这种格式：12345678struct Inner&#123; int a; char *b;&#125;struct Outter &#123;unsigned int count;Inner* pInner;&#125; 一个API接收一个Outter数组指针： 1extern \"C\" declspec(_dllexport) void func(Outter *param, unsigned int count); 此时在python端，我们需要定义相应的数据结构，如果在C的代码中使用了指针，那么对应在python端也需要使用POINTER： 123456class Inner(Structure): _fields_ = [(\"a\", c_int), (\"b\",c_char_p)]class Outter(Structure): _fields_ = [(\"count\", c_uint), (\"pInner\", POINTER(Inner))] 这样，在调用的时候，Outter的实例外层加上byref即可： 1234count = 2outter_type = Ouuter * countoutter = outter_type()dll.func(byref(outter), c_uint(count)) matplotlib发现在测试接口中，有些数据集和时间相关。直接从接口中返回的数据倒是有了，但是很难高效地验证数据的有效性。此时借助matplotlib，将数据集通过图表的形式展示出来，就大大提高了验证数据有效性的效率，同时也很方便观察。","categories":[{"name":"编程","slug":"编程","permalink":"http://codingeek.me/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://codingeek.me/tags/python/"},{"name":"dll","slug":"dll","permalink":"http://codingeek.me/tags/dll/"}]},{"title":"开篇","slug":"开篇","date":"2017-01-21T11:59:19.000Z","updated":"2017-02-12T00:33:07.955Z","comments":true,"path":"2017/01/21/开篇/","link":"","permalink":"http://codingeek.me/2017/01/21/开篇/","excerpt":"","text":"看来必须得看下markdown的语法了，要不然都下去手。","categories":[{"name":"杂说","slug":"杂说","permalink":"http://codingeek.me/categories/杂说/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://codingeek.me/tags/杂谈/"}]}]}